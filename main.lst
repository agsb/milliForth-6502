ca65 V2.19 - Git 7979f8a41
Main file   : main.s
Current file: main.s

000000r 1               ;----------------------------------------------------------------------
000000r 1               ;   MilliForth for 6502
000000r 1               ;
000000r 1               ;   original for the 6502, by Alvaro G. S. Barcellos, 2023
000000r 1               ;
000000r 1               ;   https://github.com/agsb
000000r 1               ;   see the disclaimer file in this repo for more information.
000000r 1               ;
000000r 1               ;   SectorForth and MilliForth was made for x86 arch
000000r 1               ;   and uses full 16-bit registers
000000r 1               ;
000000r 1               ;   The way at 6502 is use a page zero and lots of lda/sta bytes
000000r 1               ;
000000r 1               ;   Focus in size not performance.
000000r 1               ;
000000r 1               ;   Changes:
000000r 1               ;
000000r 1               ;   all data (36 cells) and return (36 cells) stacks, locals (16 cells) and tib (80 bytes) are in same page $200, 256 bytes;
000000r 1               ;
000000r 1               ;   tib and locals grows forward, stacks grows backwards, no overflow or underflow checks;
000000r 1               ;
000000r 1               ;   only immediate flag used as $80, no hide, no compile, no extras;
000000r 1               ;
000000r 1               ;   As Forth-1994: ; FALSE is $0000 ; TRUE  is $FFFF ;
000000r 1               ;
000000r 1               ;   Remarks:
000000r 1               ;
000000r 1               ;   words must be between spaces, begin and end spaces are necessary;
000000r 1               ;
000000r 1               ;   if locals 'still' not used, data stack could be 52 cells
000000r 1               ;
000000r 1               ;   For 6502:
000000r 1               ;
000000r 1               ;   hardware stack not used as forth stack, just for jsr/rts and pha/pla
000000r 1               ;
000000r 1               ;   6502 is a byte processor, no need 'pad' at end of even names;
000000r 1               ;
000000r 1               ;----------------------------------------------------------------------
000000r 1               ;
000000r 1               ; stuff for ca65
000000r 1               ;
000000r 1               .p02
000000r 1               .feature c_comments
000000r 1               .feature string_escapes
000000r 1               .feature org_per_seg
000000r 1               .feature dollar_is_pc
000000r 1               .feature pc_assignment
000000r 1               
000000r 1               ;---------------------------------------------------------------------
000000r 1               ; label for primitives
000000r 1               .macro makelabel arg1, arg2
000000r 1               .ident (.concat (arg1, arg2)):
000000r 1               .endmacro
000000r 1               
000000r 1               ; header for primitives
000000r 1               ; the entry point for dictionary is f_~name~
000000r 1               ; the entry point for code is ~name~
000000r 1               .macro def_word name, label, flag
000000r 1               ;this = *
000000r 1               makelabel "f_", label
000000r 1                   .ident(.sprintf("H%04X", hcount + 1)) = *
000000r 1                   .word .ident (.sprintf ("H%04X", hcount))
000000r 1                   hcount .set hcount + 1
000000r 1                   .byte .strlen(name) + flag + 0 ; nice trick !
000000r 1                   .byte name
000000r 1                   .word $0000 ; needed for MITC
000000r 1               makelabel "", label
000000r 1               .endmacro
000000r 1               
000000r 1               H0000 = 0
000000r 1               
000000r 1               hcount .set 0
000000r 1               
000000r 1               debug = 0
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; alias
000000r 1               
000000r 1               ; cell size
000000r 1               CELL   =  2     ; 16 bits
000000r 1               
000000r 1               ; highlander
000000r 1               FLAG_IMM  =  1<<7
000000r 1               
000000r 1               ; terminal input buffer, 80 bytes forward
000000r 1               tib = $0200
000000r 1               
000000r 1               ; locals, 16 words forward
000000r 1               lcs = $0250
000000r 1               
000000r 1               ; data stack base, 36 words deep backward
000000r 1               dsb = $02DC
000000r 1               
000000r 1               ; return stack base, 36 words deep backward
000000r 1               rsb = $02FF
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               .segment "ZERO"
000000r 1               
000000r 1               * = $E0
0000E0  1               ; default pseudo registers
0000E0  1  00 00        nil:    .word $0 ; reserved reference offset
0000E2  1  00 00        dta:    .word $0 ; holds data stack base,
0000E4  1  00 00        rte:    .word $0 ; holds return stack base
0000E6  1  00 00        lnk:    .word $0 ; link for inner return
0000E8  1               
0000E8  1               ; default Forth pseudo registers
0000E8  1  00 00        tos:    .word $0 ; top on stack, first
0000EA  1  00 00        nos:    .word $0 ; next on stack, second
0000EC  1  00 00        wrk:    .word $0 ; work, generic holder
0000EE  1  00 00        tmp:    .word $0 ; temporary holder
0000F0  1               
0000F0  1               ; default Forth variables
0000F0  1  00 00        state:  .word $0 ; state, only lsb used
0000F2  1  00 00        toin:   .word $0 ; toin, only lsb used
0000F4  1  00 00        last:   .word $0 ; last link cell
0000F6  1  00 00        here:   .word $0 ; next free cell
0000F8  1               
0000F8  1               ;----------------------------------------------------------------------
0000F8  1               ;
0000F8  1               ;----------------------------------------------------------------------
0000F8  1               ;.segment "ONCE"
0000F8  1               ; no rom code
0000F8  1               
0000F8  1               ;----------------------------------------------------------------------
0000F8  1               ;.segment "VECTORS"
0000F8  1               ; no boot code
0000F8  1               
0000F8  1               ;----------------------------------------------------------------------
0000F8  1               .segment "CODE"
000000r 1               ;
000000r 1               ; leave space for page zero, hard stack, buffer and forth stacks
000000r 1               ;
000000r 1               * = $300
000300  1               
000300  1               main:
000300  1               
000300  1                   ; latest link
000300  1  A9 60            lda #<f_semis
000302  1  85 F4            sta last + 0
000304  1  A9 05            lda #>f_semis
000306  1  85 F5            sta last + 1
000308  1               
000308  1                   ; next free memory cell
000308  1  A9 00            lda #<init
00030A  1  85 F6            sta here + 0
00030C  1  A9 06            lda #>init
00030E  1  85 F7            sta here + 1
000310  1               
000310  1                   ; self pointer
000310  1  A9 E0            lda #<nil
000312  1  85 E0            sta nil + 0
000314  1  A9 00            lda #>nil
000316  1  85 E1            sta nil + 1
000318  1               
000318  1               ;---------------------------------------------------------------------
000318  1               error:
000318  1               
000318  1  A9 0D            lda #13
00031A  1  20 22 04         jsr putchar
00031D  1               
00031D  1                   .if debug
00031D  1                   jsr erro
00031D  1                   .endif
00031D  1               
00031D  1               ;---------------------------------------------------------------------
00031D  1               quit:
00031D  1               
00031D  1                   ; reset stacks
00031D  1  A0 00            ldy #>rte
00031F  1  84 E3            sty dta + 1
000321  1  84 E5            sty rte + 1
000323  1               
000323  1  A0 DC            ldy #$DC
000325  1  84 E2            sty dta + 0
000327  1  A0 FF            ldy #$FF
000329  1  84 E4            sty rte + 0
00032B  1               
00032B  1                   ; clear tib stuff
00032B  1  C8               iny
00032C  1  84 F2            sty toin + 0
00032E  1  8C 00 02         sty tib + 0
000331  1               
000331  1                   ; state is 'interpret' == 0
000331  1  84 F0            sty state + 0
000333  1               
000333  1               ;---------------------------------------------------------------------
000333  1               ; the outer loop
000333  1               outer:
000333  1               
000333  1  00 00            .word $0000
000335  1               
000335  1                   .if debug
000335  1                   jsr showdic
000335  1                   .endif
000335  1               
000335  1                   ; magic loop
000335  1  A9 33            lda #<outer
000337  1  85 E8            sta tos + 0
000339  1  A9 03            lda #>outer
00033B  1  85 E9            sta tos + 1
00033D  1  20 07 04         jsr rpush
000340  1               
000340  1               find:
000340  1                   ; get a token, (nos)
000340  1  20 B0 03         jsr token
000343  1               
000343  1                   ; load lastest link
000343  1  A9 F4            lda #<last
000345  1  85 EC            sta wrk + 0
000347  1  A9 00            lda #>last
000349  1  85 ED            sta wrk + 1
00034B  1               
00034B  1               @loop:
00034B  1               
00034B  1                   ; update link list
00034B  1  A5 EC            lda wrk + 0
00034D  1  85 E8            sta tos + 0
00034F  1               
00034F  1                   ; verify is zero
00034F  1  05 ED            ora wrk + 1
000351  1  F0 C5            beq error ; end of dictionary, no more words to search, quit
000353  1               
000353  1                   ; update link list
000353  1  A5 ED            lda wrk + 1
000355  1  85 E9            sta tos + 1
000357  1               
000357  1                   ; get that link, wrk = [tos]
000357  1                   ; bypass the link tos+2
000357  1  A2 08            ldx #(tos - nil) ; from
000359  1  A0 0C            ldy #(wrk - nil) ; into
00035B  1  20 F2 03         jsr pull
00035E  1               
00035E  1                   ; compare words
00035E  1  A0 00            ldy #0
000360  1               
000360  1                   ; save the flag at size byte
000360  1  B1 E8            lda (tos), y
000362  1  48               pha
000363  1               
000363  1               @equal:
000363  1  B1 EA            lda (nos), y
000365  1                   ; space ends token
000365  1  C9 20            cmp #32
000367  1  F0 0A            beq @done
000369  1                   ; verify
000369  1  38               sec
00036A  1  F1 E8            sbc (tos), y
00036C  1                   ; 7-bit ascii, also mask flag
00036C  1  29 7F            and #$7F
00036E  1  D0 DB            bne @loop
000370  1                   ; next char
000370  1  C8               iny
000371  1  D0 F0            bne @equal
000373  1               @done:
000373  1               
000373  1                   ; update tos
000373  1  98               tya
000374  1                   ; implict ldx #(tos - nil)
000374  1  20 D5 03         jsr addw
000377  1               
000377  1                   ; compile or execute
000377  1  68               pla             ; immediate ?
000378  1  30 07            bmi @execw      ; bit 7 set if < 0
00037A  1               
00037A  1  A5 F0            lda state + 0   ; executing ?
00037C  1  D0 03            bne @execw
00037E  1               
00037E  1               ; zzzz how does return ? need a branch or jump to outer
00037E  1               
00037E  1               @compw:
00037E  1               
00037E  1  4C 78 05         jmp compile
000381  1               
000381  1               @execw:
000381  1               
000381  1  4C 0C 05         jmp next_
000384  1               
000384  1               ;---------------------------------------------------------------------
000384  1               try_:
000384  1  B9 00 02         lda tib, y
000387  1  F0 04            beq newline_    ; if \0
000389  1  C8               iny
00038A  1  49 20            eor #32
00038C  1  60               rts
00038D  1               
00038D  1               ;---------------------------------------------------------------------
00038D  1               ; a page of 254 for buffer, but reserve 3 bytes. (but 72 is enough)
00038D  1               ; no edits, no colapse spcs, no continue between lines
00038D  1               
00038D  1               newline_:
00038D  1                   ; drop rts of try_
00038D  1  68               pla
00038E  1  68               pla
00038F  1                   ; leave a space
00038F  1  A0 01            ldy #1
000391  1               @loop:
000391  1  20 1F 04         jsr getchar
000394  1                   ;
000394  1                   ; unix like
000394  1                   ;
000394  1  C9 0A            cmp #10         ; \n ?
000396  1  F0 08            beq @endline
000398  1                   ;
000398  1                   ; dos like
000398  1                   ;
000398  1                   ;   cmp #13     ; \r ?
000398  1                   ;   beq @endline
000398  1                   ;
000398  1                   ; clear to start of line
000398  1                   ;   cmp #15     ; \u ?
000398  1                   ;   beq
000398  1                   ;   jmp @fill
000398  1                   ;
000398  1               @puts:
000398  1  29 7F            and #$7F        ; 7-bit ascii
00039A  1  99 00 02         sta tib, y
00039D  1  C8               iny
00039E  1  D0 F1            bne @loop
0003A0  1               ; must panic if y eq \0 ?
0003A0  1               ; or
0003A0  1               @endline:
0003A0  1                   ; grace
0003A0  1  A9 20            lda #32
0003A2  1  8D 00 02         sta tib + 0 ; start with space
0003A5  1  99 00 02         sta tib, y  ; ends with space
0003A8  1                   ; and end of line
0003A8  1  A9 00            lda #0
0003AA  1  C8               iny
0003AB  1  99 00 02         sta tib, y
0003AE  1  85 F2            sta toin + 0
0003B0  1               
0003B0  1                   .if debug
0003B0  1                   jsr showtib
0003B0  1                   .endif
0003B0  1               
0003B0  1               ;---------------------------------------------------------------------
0003B0  1               ;
0003B0  1               ; toin + 0 effective offset
0003B0  1               ; toin + 1 scratch for size
0003B0  1               ;
0003B0  1               token:
0003B0  1                   ; last position on tib
0003B0  1  A4 F2            ldy toin + 0
0003B2  1               
0003B2  1               @skip:
0003B2  1                   ; skip spaces
0003B2  1  20 84 03         jsr try_
0003B5  1  F0 FB            beq @skip
0003B7  1               
0003B7  1                   ; keep start
0003B7  1  88               dey
0003B8  1  84 F3            sty toin + 1
0003BA  1               
0003BA  1               @scan:
0003BA  1                   ; scan spaces
0003BA  1  20 84 03         jsr try_
0003BD  1  D0 FB            bne @scan
0003BF  1               
0003BF  1                   ; keep stop
0003BF  1  88               dey
0003C0  1  84 F2            sty toin + 0
0003C2  1               
0003C2  1                   ; strlen
0003C2  1  38               sec
0003C3  1  98               tya
0003C4  1  E5 F3            sbc toin + 1
0003C6  1               
0003C6  1                   ; keep size
0003C6  1  A4 F3            ldy toin + 1
0003C8  1  88               dey
0003C9  1  99 00 02         sta tib, y  ; store size ahead
0003CC  1               
0003CC  1                   ; setup token, pass pointer
0003CC  1  84 EA            sty nos + 0
0003CE  1  A9 02            lda #>tib
0003D0  1  85 EB            sta nos + 1
0003D2  1               
0003D2  1  60               rts
0003D3  1               
0003D3  1               ;---------------------------------------------------------------------
0003D3  1               ; increment a word in page zero, offset by X
0003D3  1               incw:
0003D3  1  A9 01            lda #1
0003D5  1               ; add a byte to a word in page zero. offset by X
0003D5  1               addw:
0003D5  1  18               clc
0003D6  1  75 E0            adc nil + 0, x
0003D8  1  95 E0            sta nil + 0, x
0003DA  1  90 02            bcc @noinc
0003DC  1  F6 E1            inc nil + 1, x
0003DE  1               @noinc:
0003DE  1  60               rts
0003DF  1               
0003DF  1               ;---------------------------------------------------------------------
0003DF  1               ; decrement a word in page zero. offset by X
0003DF  1               decw:
0003DF  1  B5 E0            lda nil + 0, x
0003E1  1  D0 02            bne @nodec
0003E3  1  D6 E1            dec nil + 1, x
0003E5  1               @nodec:
0003E5  1  D6 E0            dec nil + 0, x
0003E7  1  60               rts
0003E8  1               
0003E8  1               ;---------------------------------------------------------------------
0003E8  1               ; pull a word
0003E8  1               ; from a page zero address indexed by X
0003E8  1               ; into a absolute page zero address indexed by y
0003E8  1               spull2:
0003E8  1  20 EE 03         jsr tspull
0003EB  1               
0003EB  1               nspull:
0003EB  1  A0 0A            ldy #(nos - nil)
0003ED  1  2C               .byte $2c   ; mask ldy, nice trick !
0003EE  1               
0003EE  1               ; pull from data stack
0003EE  1               tspull:
0003EE  1  A0 08            ldy #(tos - nil)
0003F0  1               
0003F0  1               ; pull from data stack
0003F0  1               spull:
0003F0  1  A2 02            ldx #(dta - nil)
0003F2  1               
0003F2  1               pull:
0003F2  1  A1 E0            lda (nil, x)
0003F4  1  99 E0 00         sta nil + 0, y
0003F7  1  20 D3 03         jsr incw
0003FA  1  A1 E0            lda (nil, x)
0003FC  1  99 E1 00         sta nil + 1, y
0003FF  1  4C D3 03         jmp incw
000402  1               
000402  1               ; pull from return stack
000402  1               rpull:
000402  1  A2 04            ldx #(rte - nil)
000404  1  4C F2 03         jmp pull
000407  1               
000407  1               ;---------------------------------------------------------------------
000407  1               ; push a word
000407  1               ; from an absolute page zero address indexed by Y
000407  1               ; into a page zero address indexed by X
000407  1               rpush:
000407  1  A2 04            ldx #(rte - nil)
000409  1  2C               .byte $2c   ; mask ldx, nice trick !
00040A  1               spush:
00040A  1  A2 02            ldx #(dta - nil)
00040C  1               
00040C  1               tpush:
00040C  1  A0 08            ldy #(tos - nil)
00040E  1               
00040E  1               push:
00040E  1  20 DF 03         jsr decw
000411  1  B9 E1 00         lda nil + 1, y
000414  1  81 E0            sta (nil, x)
000416  1  20 DF 03         jsr decw
000419  1  B9 E0 00         lda nil + 0, y
00041C  1  81 E0            sta (nil, x)
00041E  1  60               rts
00041F  1               
00041F  1               ;---------------------------------------------------------------------
00041F  1               ; for lib6502  emulator
00041F  1               ; does echo
00041F  1               getchar:
00041F  1  AD 00 E0         lda $E000
000422  1               
000422  1               putchar:
000422  1  8D 00 E0         sta $E000
000425  1               
000425  1  60               rts
000426  1               
000426  1               ;---------------------------------------------------------------------
000426  1               ; all primitives ends with jmp unnest_
000426  1               ;
000426  1               
000426  1               ;---------------------------------------------------------------------
000426  1  00 00 03 6B  def_word "key", "key", 0
00042A  1  65 79 00 00  
00042E  1  20 1F 04        jsr getchar
000431  1  85 E8           sta tos + 0
000433  1  4C 9B 04        jmp used
000436  1               
000436  1               ;---------------------------------------------------------------------
000436  1  26 04 04 65  def_word "emit", "emit", 0
00043A  1  6D 69 74 00  
00043E  1  00           
00043F  1  20 EE 03        jsr tspull
000442  1  A5 E8           lda tos + 0
000444  1  20 22 04        jsr putchar
000447  1  4C 07 05        jmp unnest_
00044A  1               
00044A  1               ;---------------------------------------------------------------------
00044A  1               ; [tos] = nos
00044A  1  36 04 01 21  def_word "!", "store", 0
00044E  1  00 00        
000450  1               storew:
000450  1  20 E8 03         jsr spull2
000453  1  A2 0A            ldx #(tos + 2 - nil) ; push starts with decw, then it works
000455  1  A0 0A            ldy #(nos - nil)
000457  1  20 0E 04         jsr push
00045A  1  4C 07 05         jmp unnest_
00045D  1               
00045D  1               ;---------------------------------------------------------------------
00045D  1               ; tos = [nos]
00045D  1  4A 04 01 40  def_word "@", "fetch", 0
000461  1  00 00        
000463  1               fetchw:
000463  1  20 EB 03         jsr nspull
000466  1  A2 0A            ldx #(nos - nil)
000468  1  A0 08            ldy #(tos - nil)
00046A  1  20 F2 03         jsr pull
00046D  1  4C 9B 04         jmp used
000470  1               
000470  1               ;---------------------------------------------------------------------
000470  1  5D 04 03 72  def_word "rp@", "rpfetch", 0
000474  1  70 40 00 00  
000478  1  A2 04            ldx #(rte - nil)
00047A  1  4C 93 04         jmp copy
00047D  1               
00047D  1               ;---------------------------------------------------------------------
00047D  1  70 04 03 73  def_word "sp@", "spfetch", 0
000481  1  70 40 00 00  
000485  1  A2 02            ldx #(dta - nil)
000487  1  4C 93 04         jmp copy
00048A  1               
00048A  1               ;---------------------------------------------------------------------
00048A  1  7D 04 02 73  def_word "s@", "statevar", 0
00048E  1  40 00 00     
000491  1  A2 10            ldx #(state - nil)
000493  1                   ; jmp copy
000493  1               
000493  1               ;---------------------------------------------------------------------
000493  1               ; generic
000493  1               ;
000493  1               copy:
000493  1  B5 E0            lda nil + 0, x
000495  1  85 E8            sta tos + 0
000497  1  B5 E1            lda nil + 1, x
000499  1               back:
000499  1  85 E9            sta tos + 1
00049B  1               used:
00049B  1  20 0A 04         jsr spush
00049E  1  4C 07 05         jmp unnest_
0004A1  1               
0004A1  1               ;---------------------------------------------------------------------
0004A1  1               ; ( nos tos -- nos + tos )
0004A1  1  8A 04 01 2B  def_word "+", "plus", 0
0004A5  1  00 00        
0004A7  1  20 E8 03         jsr spull2
0004AA  1  18               clc
0004AB  1  A5 EA            lda nos + 0
0004AD  1  65 E8            adc tos + 0
0004AF  1  85 E8            sta tos + 0
0004B1  1  A5 EB            lda nos + 1
0004B3  1  65 E9            adc tos + 1
0004B5  1  4C 99 04         jmp back
0004B8  1               
0004B8  1               ;---------------------------------------------------------------------
0004B8  1               ; ( nos tos -- NOT(nos AND tos) )
0004B8  1  A1 04 04 6E  def_word "nand", "nand", 0
0004BC  1  61 6E 64 00  
0004C0  1  00           
0004C1  1  20 E8 03         jsr spull2
0004C4  1  A5 EA            lda nos + 0
0004C6  1  25 E8            and tos + 0
0004C8  1  49 FF            eor #$FF
0004CA  1  85 E8            sta tos + 0
0004CC  1  A5 EB            lda nos + 1
0004CE  1  25 E9            and tos + 1
0004D0  1  49 FF            eor #$FF
0004D2  1  4C 99 04         jmp back
0004D5  1               
0004D5  1               ;---------------------------------------------------------------------
0004D5  1               ; test if tos == \0
0004D5  1  B8 04 02 30  def_word "0#", "zeroq", 0
0004D9  1  23 00 00     
0004DC  1  20 EE 03         jsr tspull
0004DF  1                   ; lda tos + 1, implicit
0004DF  1  05 E8            ora tos + 0
0004E1  1  F0 06            beq istrue  ; is \0
0004E3  1               isfalse:
0004E3  1  A9 00            lda #$00
0004E5  1               rest:
0004E5  1  85 E8            sta tos + 0
0004E7  1  F0 B0            beq back
0004E9  1               istrue:
0004E9  1  A9 FF            lda #$FF
0004EB  1  D0 F8            bne rest
0004ED  1               
0004ED  1               ;---------------------------------------------------------------------
0004ED  1               ; shift right
0004ED  1  D5 04 02 32  def_word "2/", "asr", 0
0004F1  1  2F 00 00     
0004F4  1  20 EE 03         jsr tspull
0004F7  1  46 E9            lsr tos + 1
0004F9  1  66 E8            ror tos + 0
0004FB  1  4C 9B 04         jmp used
0004FE  1               
0004FE  1               ;---------------------------------------------------------------------
0004FE  1               ; minimal indirect thread code
0004FE  1               ; lnk must be preserved, as IP
0004FE  1               ;
0004FE  1  ED 04 04 65  def_word "exit", "exit", 0
000502  1  78 69 74 00  
000506  1  00           
000507  1               inner:
000507  1               
000507  1               unnest_:
000507  1                   ; pull tos = [rte], rte+2
000507  1  A0 06            ldy #(lnk - nil)
000509  1  20 02 04         jsr rpull
00050C  1               
00050C  1               next_:
00050C  1                   ; wrk = (lnk) ; lnk = lnk + 2
00050C  1  A0 0C            ldy #(wrk - nil)
00050E  1  A2 06            ldx #(lnk - nil)
000510  1  20 F2 03         jsr pull
000513  1               
000513  1                   ; is a primitive ?
000513  1  A5 EC            lda wrk + 0
000515  1  05 ED            ora wrk + 1
000517  1  D0 03            bne nest_
000519  1               jump_:
000519  1  6C E6 00         jmp (lnk)
00051C  1               
00051C  1               nest_:
00051C  1                   ; push into return stack
00051C  1  20 07 04         jsr rpush
00051F  1               
00051F  1               link_:
00051F  1  A5 EC            lda wrk + 0
000521  1  85 E6            sta lnk + 0
000523  1  A5 ED            lda wrk + 1
000525  1  85 E7            sta lnk + 1
000527  1  4C 0C 05         jmp next_
00052A  1               
00052A  1               
00052A  1               ;---------------------------------------------------------------------
00052A  1  FE 04 01 3A  def_word ":", "colon", 0
00052E  1  00 00        
000530  1                   ; save here
000530  1  A5 F6            lda here + 0
000532  1  48               pha
000533  1  A5 F7            lda here + 1
000535  1  48               pha
000536  1               
000536  1                   ; save link
000536  1  A5 F4            lda last + 0
000538  1  85 F6            sta here + 0
00053A  1  A5 F5            lda last + 1
00053C  1  85 F7            sta here + 1
00053E  1               
00053E  1                   ; setup here
00053E  1  A2 16            ldx #(here - nil)
000540  1               
000540  1                   ; update here
000540  1  A9 02            lda #$2
000542  1  20 D5 03         jsr addw
000545  1               
000545  1                   ; get the token, at nos
000545  1  20 B0 03         jsr token
000548  1               
000548  1                   ;copy size and name
000548  1  A0 00            ldy #0
00054A  1               @loop:
00054A  1  B1 EA            lda (nos), y
00054C  1  C9 20            cmp #32     ; stops at space
00054E  1  F0 05            beq @endname
000550  1  91 F6            sta (here), y
000552  1  C8               iny
000553  1  D0 F5            bne @loop
000555  1               @endname:
000555  1               
000555  1                   ; update here
000555  1  98               tya
000556  1                   ; implicit ldx #(here - nil)
000556  1  20 D5 03         jsr addw
000559  1               
000559  1                   ; state is 'compile'
000559  1               
000559  1  A9 01            lda #1
00055B  1  85 F0            sta state + 0
00055D  1               
00055D  1  4C 07 05         jmp unnest_
000560  1               
000560  1               ;---------------------------------------------------------------------
000560  1  2A 05 81 3B  def_word ";", "semis", FLAG_IMM
000564  1  00 00        
000566  1               
000566  1                   ; update last
000566  1               
000566  1  68               pla
000567  1  85 F5            sta last + 1
000569  1  68               pla
00056A  1  85 F4            sta last + 0
00056C  1               
00056C  1                   ; state is 'interpret'
00056C  1  A9 00            lda #0
00056E  1  85 F0            sta state + 0
000570  1               
000570  1                   ; compounds words must ends with 'unnest'
000570  1  A9 07            lda #<unnest_
000572  1  85 E8            sta tos + 0
000574  1  A9 05            lda #>unnest_
000576  1  85 E9            sta tos + 1
000578  1               
000578  1                   ; jsr spush
000578  1               
000578  1                   ; jmp compile
000578  1               
000578  1                   ; def_word ",", "comma",
000578  1               
000578  1               compile:
000578  1               
000578  1                   ; jsr spull
000578  1               
000578  1  A2 16            ldx #(here - nil)
00057A  1  20 0C 04         jsr tpush
00057D  1               
00057D  1  4C 07 05         jmp unnest_
000580  1               
000580  1               ;---------------------------------------------------------------------
000580  1               ends:
000580  1               
000580  1               ; debug stuff
000580  1               .if debug
000580  1               
000580  1               erro:
000580  1                   lda #'?'
000580  1                   jsr putchar
000580  1                   lda #'?'
000580  1                   jsr putchar
000580  1                   lda #10
000580  1                   jsr putchar
000580  1                   lda #13
000580  1                   jsr putchar
000580  1                   rts
000580  1               
000580  1               okey:
000580  1                   lda #'O'
000580  1                   jsr putchar
000580  1                   lda #'K'
000580  1                   jsr putchar
000580  1                   lda #10
000580  1                   jsr putchar
000580  1                   lda #13
000580  1                   jsr putchar
000580  1                   rts
000580  1               
000580  1               showdic:
000580  1               
000580  1                   php
000580  1                   pha
000580  1                   tya
000580  1                   pha
000580  1                   txa
000580  1                   pha
000580  1               
000580  1                   ; load lastest link
000580  1                   lda #<last
000580  1                   sta wrk + 0
000580  1                   lda #>last
000580  1                   sta wrk + 1
000580  1               
000580  1               @loop:
000580  1               
000580  1                   ; update link list
000580  1                   lda wrk + 0
000580  1                   sta tos + 0
000580  1               
000580  1                   ; verify is zero
000580  1                   ora wrk + 1
000580  1                   beq @ends ; end of dictionary, no more words to search, quit
000580  1               
000580  1                   ; update link list
000580  1                   lda wrk + 1
000580  1                   sta tos + 1
000580  1               
000580  1                   ; get that link, wrk = [tos]
000580  1                   ; bypass the link tos+2
000580  1                   ldx #(tos - nil) ; from
000580  1                   ldy #(wrk - nil) ; into
000580  1                   jsr pull
000580  1               
000580  1                   ldy #0
000580  1                   lda (tos), y
000580  1                   and #$7F
000580  1                   tax
000580  1               
000580  1                   adc #' '
000580  1                   jsr putchar
000580  1               
000580  1               @loopa:
000580  1                   iny
000580  1                   lda (tos), y
000580  1                   jsr putchar
000580  1                   dex
000580  1                   bne @loopa
000580  1               
000580  1                   lda #10
000580  1                   jsr putchar
000580  1               
000580  1                   jmp @loop
000580  1               
000580  1               @ends:
000580  1               
000580  1                   pla
000580  1                   tax
000580  1                   pla
000580  1                   tay
000580  1                   pla
000580  1                   plp
000580  1               
000580  1                   rts
000580  1               
000580  1               showtib:
000580  1                   lda #'>'
000580  1                   jsr putchar
000580  1                   ldy #0
000580  1               @loop:
000580  1                   lda tib, y
000580  1                   beq @done
000580  1                   jsr putchar
000580  1                   iny
000580  1                   bne @loop
000580  1               @done:
000580  1                   lda #'<'
000580  1                   jsr putchar
000580  1                   rts
000580  1               
000580  1               .endif
000580  1               
000580  1  xx xx xx xx  .align $100
000584  1  xx xx xx xx  
000588  1  xx xx xx xx  
000600  1               ; for anything above is not a primitive
000600  1               init:
000600  1               
000600  1               
000600  1               
