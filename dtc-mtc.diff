22a23
> ;----------------------------------------------------------------------
37a39
> ;----------------------------------------------------------------------
40c42
< ;       this code uses Direct Thread Code, aka DTC.
---
> ;       this code uses Minimal Thread Code, aka MTC.
62a65
> ;----------------------------------------------------------------------
74a78
> ;----------------------------------------------------------------------
95c99
< ;   At page 3:
---
> ;   From page 3 onwards:
97c101
< ;   |$0300 cold, warm, forth code, init: here> heap ... tail ????| 
---
> ;   |$0300 cold:, warm:, forth code, init: here> heap ... tail| 
101a106
> ;----------------------------------------------------------------------
105c110
< ;       to allow : dup sp@ @ ; then sp must point to actual TOS
---
> ;       to allow : dup sp@ @ ; so sp must point to actual TOS.
107,108c112
< ;   The movements will be:
< ;       push is 'decrease and store'
---
> ;   The movement will be:
109a114
> ;       push is 'decrease and store'
117c122
< ;   Do not risk to put stacks with $FF also no routine endings with.
---
> ;   Do not risk to put stacks with $FF.
119c124
< ;   Must carefull inspect if any label ends with $FF and move it;
---
> ;   Also carefull inspect if any label ends with $FF and move it;
121c126
< ;   This source is for Ca65.
---
> ;   This source is hacked for use with Ca65.
123c128,131
< ;   Stacks represented as (S: w3 w2 w1 -- u2 u1)
---
> ;----------------------------------------------------------------------
> ;
> ;   Stacks represented as 
> ;       S(w3 w2 w1 -- u2 u1)  R(w3 w2 w1 -- u2 u1)
137a146,153
> ; macros for dictionary, makes:
> ;
> ;   h_name:
> ;   .word  link_to_previous_entry
> ;   .byte  strlen(name) + flags
> ;   .byte  name
> ;   name:
> ;
184c200
< ; terminal input buffer, 80 bytes, forward
---
> ; terminal input buffer, forward
187a204,205
> ; reserve 80 bytes, (72 is enough) 
> ; moves forwards
191c209
< ; moves backwards and push decreases before copy
---
> ; moves backwards, push decreases before copy
195c213
< ; moves backwards and push decreases before copy
---
> ; moves backwards, push decreases before copy
198,199c216,217
< ; magic NOP (EA) JSR (20), at CFA cell
< magic = $20EA
---
> ; reserved for scribbles
> pic = rp0
210c228
< ; order matters for HELLO.forth !
---
> ; order matters for hello_world.forth !
285,286c303,304
<     ldy #<h_exit
<     sty last + 0
---
>     lda #<h_exit
>     sta last + 0
288,289c306,307
< ; next heap free cell  
<     ;;lda #>init
---
> ; next heap free cell, same as init:  
>     lda #>ends + 1
291,292c309,310
<     ldy #<init
<     sty here + 0
---
>     lda #0
>     sta here + 0
323,325c341
< ; like a begin-again
< 
< parse_:
---
> parsept:
326a343
> 
341a359,361
>     ; lda #'P'
>     ; jsr putchar
> 
352c372
<     sta fst + 0
---
>     sta wrd + 0
358c378,381
< ;;   uncomment for feedback, comment out "beq quit" above
---
> ;   maybe to place a code for number? 
> ;   but not for now.
> 
> ;;   uncomment for feedback, comment out deq quit" above
365,366c388,390
< ;
< ;    jmp quit  ; end of dictionary, no more words to search, quit
---
> 
> ;   not found what to do ?
>     ; jmp quit  ; end of dictionary, no more words to search, quit
372c396
<     sta fst + 1
---
>     sta wrd + 1
375c399
<     ldx #(fst) ; from 
---
>     ldx #(wrd) ; from 
383c407
<     lda (fst), y
---
>     lda (wrd), y
394c418
<     sbc (fst), y     
---
>     sbc (wrd), y     
396c420
<     asl
---
>     asl        
404c428
< ; update fst
---
> ; update wrd
406c430,431
<     ;;ldx #(fst) ; set already
---
>     ;; ldx #(wrd) ; set already
>     ;; addwx also clear carry
410,414d434
<     ; if execute is FLAG_IMM
<     ; lda stat + 1
<     ; ora stat + 0
<     ; bmi execute
< 
425c445,446
<     jsr fcomma
---
>     ; lda #'C'
>     ; jsr putchar
427c448,450
<     bcc parse   ; always taken
---
>     jsr wcomma
> 
>     bcc parse
431c454,458
<     lda #>parse_
---
> 
>     ; lda #'E'
>     ; jsr putchar
> 
>     lda #>parsept
433c460
<     lda #<parse_
---
>     lda #<parsept
436,437c463,464
<     jmp (fst)
< 
---
>     jmp pick
>     
456c483
<     sta tib, y     ; dummy store on first pass, overwritten later
---
>     sta tib, y  ; dummy store on first pass, overwritten
461a489
> ; then 
495,496d522
< ; keep start 
<     sty tout + 0    
500a527,530
> ; keep y == start + 1
>     dey
>     sty tout + 0
> 
502,503d531
< ; keep stop 
<     sty toin + 0 
507a536,539
> ; keep y == stop + 1  
>     dey
>     sty toin + 0 
> 
511c543
<     clc
---
>     sec
516,517c548,550
<     sta tib - 1, y  ; store size for counted string 
<     dec tout + 0
---
>     dey
>     sta tib, y  ; store size for counted string 
>     sty tout + 0
519a553
>     clc     ; clean 
522a557,558
> ;  this code depends on systems or emulators
> ;
523a560
> ; 
527,534c564,566
< ; getchar returns 0xFF at EOF
<     cmp #$FF
< .ifndef extras
<     bne putchar
< ; exit for emulator  
<     pha
<     pha
< .else
---
> eofs:
> ; EOF ?
>     cmp #$FF ; also clean carry :)
536d567
< .endif
542d572
< .ifdef extras
546c576,579
< .endif
---
> 
> ;
> ;   lib6502 emulator
> ;---------------------------------------------------------------------
571,574c604
<     sta fst + 1
< 
< fcomma:    
<     ldy #(fst)
---
>     ldy #(wrd)
589c619
<     bcc incwx   ; always taken
---
>     jmp incwx
598d627
<     ;;bne spush   ; fall through
624,627d652
< ;
< ; generics 
< ;
< ;---------------------------------------------------------------------
636c661
<     ;;bne spull   ; fall through
---
>     ; fall through
652c677,678
< pull: ; fall through, same as copyfrom
---
> pull:   ; fall through, same as copyfrom
> 
658c684
<     sta  0, y
---
>     sta 0, y
661,662c687,688
<     sta  1, y
<     ;;bcc incwx ; fall through
---
>     sta 1, y
>     ; jmp incwx ; fall through
676c702
<     clc
---
>     clc ; keep carry clean
680d705
< 
803a829
>     clc  ; clean
868,870c894,899
< ; thanks, @https://codebase64.org/doku.php?id=base:
< ;   16-bit_absolute_comparison
< ; check if primitive
---
> ; show CFA
> 
>     lda #' '
>     jsr putchar
>     lda fst + 1
>     jsr puthex
872c901,903
<     cmp #<init
---
>     jsr puthex
> 
> ; check if is a primitive
874,875c905
<     sbc #>init
<     eor fst + 1
---
>     cmp #>ends + 1
885a916
>     clc  ; clean
922c953
<     bne @next
---
>     bne @step
928c959
< @next:
---
> @step:
932a964
>     clc  ; clean
984a1017
>     clc  ; clean
1016a1050
>     clc  ; clean
1055c1089
<     clc
---
>     clc ; clean
1101,1123d1134
< ;---------------------------------------------------------------------
< rpull1:
<     ldy #(fst)
<     jmp rpull
< 
< ;---------------------------------------------------------------------
< rpush1:
<     ldy #(fst)
<     jmp rpush
< 
< ;---------------------------------------------------------------------
< ; ( w -- ) ( -- w ) from data stack into return stack
< def_word ">r", "stor", 0 
<     jsr spull1
<     jsr rpush1
<     jmp next
< 
< ; ( -- w ) ( w -- ) from return stack into data stack
< def_word "r>", "rtos", 0 
<     jsr rpull1
<     jsr spush1
<     jmp next
< 
1128c1139
< 
---
> ; start of dictionary
1133a1145
>     ; jmp this  ; uncomment if char could be \0
1141a1154
>     ; jmp next  ; uncomment if carry could be set
1152c1165,1166
<     bcc jmpnext    ; always taken
---
>     ; jmp next  ; uncomment if carry could be set
>     bcc jmpnext ; always taken
1165c1179,1180
<     bcc keeps   ; always taken
---
>     ; jmp keeps  ; uncomment if carry could be set
>     bcc keeps ; always taken
1171c1186
<     ;;clc ; cleared already
---
>     clc  ; better safe than sorry
1191,1192c1206,1207
<     ldx 0, y
<     stx fst + 0
---
>     lda 0, y
>     sta fst + 0
1213c1228,1230
<     bne stafst  ; always taken
---
> isfalse:
>     sta fst + 0                                                         
>     jmp keeps  
1219,1220d1235
< isfalse:
< stafst:
1222a1238
>     ;  jmp keeps ; uncomment if stats not in page $0
1226,1243d1241
< ; moved to hello_world
< ; ( -- sp )
< ;def_word "sp@", "spat", 0
< ;    lda spt + 0
< ;    sta fst + 0
< ;    lda spt + 1
< ;    jmp keeps 
< 
< ;---------------------------------------------------------------------
< ; moved to hello_world
< ; ( -- rp )
< ;def_word "rp@", "rpat", 0
< ;    lda rpt + 0
< ;    sta fst + 0
< ;    lda rpt + 1
< ;    jmp keeps 
< 
< ;---------------------------------------------------------------------
1257c1255
<     sta fst + 0
---
>     sta wrd + 0
1258a1257
>     sta wrd + 1
1260a1260
>     ; jmp next
1269a1270
> 
1298,1309d1298
< ; inserts the nop call 
<     lda #$EA
<     sta fst + 0
<     lda #$20
<     jsr wcomma
< 
< ; inserts the reference
<     lda #<nest
<     sta fst + 0
<     lda #>nest
<     jsr wcomma
< 
1310a1300
>     ; jmp next
1314c1304
< ; classic direct thread code
---
> ; minimal thread code
1324c1314
< unnest:
---
> unnest: ; exit
1335,1336c1325,1330
< jump:
<     jmp (wrd)
---
> pick:
> ; compare pages (MSBs)
>     lda wrd + 1
>     cmp #>ends + 1
>     ; cmp #>init
>     bmi jump
1343,1344c1337
< ; pull (ip),  
<     pla
---
>     lda wrd + 0
1346c1339
<     pla
---
>     lda wrd + 1
1349,1353c1342
< ; 6502 trick: must increase return address 
<     ldx #(ipt)
<     jsr incwx
<     
<     bcc next    ; always taken
---
>     jmp next
1354a1344,1349
> jump: 
> 
>     jmp (wrd)
> 
> ;----------------------------------------------------------------------
> ; end of code
1359,1361c1354,1357
< ; .align $100
< 
< init:   
---
> ; needed for MTC
> ; same as #>end+1
> ;.align $100
> ;init:   
