22a23
> ;----------------------------------------------------------------------
37a39
> ;----------------------------------------------------------------------
62a65
> ;----------------------------------------------------------------------
74a78
> ;----------------------------------------------------------------------
95c99
< ;   At page 3:
---
> ;   From page 3 onwards:
97c101
< ;   |$0300 cold, warm, forth code, init: here> heap ... tail ????| 
---
> ;   |$0300 cold:, warm:, forth code, init: here> heap ... tail| 
101a106
> ;----------------------------------------------------------------------
105c110
< ;       to allow : dup sp@ @ ; then sp must point to actual TOS
---
> ;       to allow : dup sp@ @ ; so sp must point to actual TOS.
107,108c112
< ;   The movements will be:
< ;       push is 'decrease and store'
---
> ;   The movement will be:
109a114
> ;       push is 'decrease and store'
117c122
< ;   Do not risk to put stacks with $FF also no routine endings with.
---
> ;   Do not risk to put stacks with $FF.
119c124
< ;   Must carefull inspect if any label ends with $FF and move it;
---
> ;   Also carefull inspect if any label ends with $FF and move it;
121c126
< ;   This source is for Ca65.
---
> ;   This source is hacked for use with Ca65.
123c128,131
< ;   Stacks represented as (S: w3 w2 w1 -- u2 u1)
---
> ;----------------------------------------------------------------------
> ;
> ;   Stacks represented as 
> ;       S(w3 w2 w1 -- u2 u1)  R(w3 w2 w1 -- u2 u1)
184c192
< ; terminal input buffer, 80 bytes, forward
---
> ; terminal input buffer, forward
187a196,197
> ; reserve 80 bytes, (72 is enough) 
> ; moves forwards
191c201
< ; moves backwards and push decreases before copy
---
> ; moves backwards, push decreases before copy
195c205
< ; moves backwards and push decreases before copy
---
> ; moves backwards, push decreases before copy
198,199c208,209
< ; magic NOP (EA) JSR (20), at CFA cell
< magic = $20EA
---
> ; reserved for scribbles
> pic = rp0
285,286c295,296
<     ldy #<h_exit
<     sty last + 0
---
>     lda #<h_exit
>     sta last + 0
289c299
<     ;;lda #>init
---
>     lda #>init
291,292c301,302
<     ldy #<init
<     sty here + 0
---
>     lda #<init
>     sta here + 0
352c362
<     sta fst + 0
---
>     sta wrd + 0
356c366
<     beq quit
---
>     bne @each
358c368
< ;;   uncomment for feedback, comment out "beq quit" above
---
> ;;   uncomment for feedback
365,366c375,376
< ;
< ;    jmp quit  ; end of dictionary, no more words to search, quit
---
> 
>     jmp quit  ; end of dictionary, no more words to search, quit
372c382
<     sta fst + 1
---
>     sta wrd + 1
375c385
<     ldx #(fst) ; from 
---
>     ldx #(wrd) ; from 
383c393
<     lda (fst), y
---
>     lda (wrd), y
394c404
<     sbc (fst), y     
---
>     sbc (wrd), y     
396c406
<     asl
---
>     and #$7F        
404c414
< ; update fst
---
> ; update wrd
406c416
<     ;;ldx #(fst) ; set already
---
>     ldx #(wrd)
425c435
<     jsr fcomma
---
>     jsr wcomma
427c437
<     bcc parse   ; always taken
---
>     jmp parse
436c446
<     jmp (fst)
---
>     jmp (wrd)
453c463
<     ldy #0
---
>     ldy #1
455,461d464
< ; is valid
<     sta tib, y     ; dummy store on first pass, overwritten later
<     iny
< ; would be better with 
< ; end of buffer ?
< ;    cpy #tib_end
< ;    beq @ends
468c471
<     bne @loop
---
>     beq @ends
472a476,482
> ; is valid
>     sta tib, y
>     iny
> ; would be better with 
> ; end of buffer ?
> ;    cpy #tib_end
>     bne @loop
480a491
>     iny
482c493
<     sta tib + 1, y
---
>     sta tib, y
495,496d505
< ; keep start 
<     sty tout + 0    
499a509,511
> ; keep start 
>     dey
>     sty tout + 0    
502,503d513
< ; keep stop 
<     sty toin + 0 
506a517,519
> ; keep stop 
>     dey
>     sty toin + 0 
511c524
<     clc
---
>     sec
516,517c529,531
<     sta tib - 1, y  ; store size for counted string 
<     dec tout + 0
---
>     dey
>     sta tib, y  ; store size for counted string 
>     sty tout + 0
529,534d542
< .ifndef extras
<     bne putchar
< ; exit for emulator  
<     pha
<     pha
< .else
536d543
< .endif
542d548
< .ifdef extras
546d551
< .endif
567a573,587
> ; increment a word in page zero. offset by X
> incwx:
>     lda #01
> ;---------------------------------------------------------------------
> ; add a byte to a word in page zero. offset by X
> addwx:
>     clc
>     adc 0, x
>     sta 0, x
>     bcc @ends
>     inc 1, x
> @ends:
>     rts
> 
> ;---------------------------------------------------------------------
570,571d589
< wcomma:
<     sta fst + 1
573,574c591,595
< fcomma:    
<     ldy #(fst)
---
> tcomma:    
>     sta wrd + 1
> 
> wcomma:    
>     ldy #(wrd)
589c610
<     bcc incwx   ; always taken
---
>     jmp incwx
592,598c613,621
< ;
< ; generics 
< ;
< ;---------------------------------------------------------------------
< spush1:
<     ldy #(fst)
<     ;;bne spush   ; fall through
---
> ; from a page zero indirect address indexed by X
> ; into a page zero address indexed by y
> copyfrom:
>     lda (0, x)
>     sta 0, y
>     jsr incwx
>     lda (0, x)
>     sta 1, y
>     jmp incwx
624,638d646
< ;
< ; generics 
< ;
< ;---------------------------------------------------------------------
< spull2:
<     ldy #(snd)
<     jsr spull
<     ; fall through
< 
< ;---------------------------------------------------------------------
< spull1:
<     ldy #(fst)
<     ;;bne spull   ; fall through
< 
< ;---------------------------------------------------------------------
652,656c660
< pull: ; fall through, same as copyfrom
< ;---------------------------------------------------------------------
< ; from a page zero indirect address indexed by X
< ; into a page zero address indexed by y
< copyfrom:
---
> pull:
662c666,667
<     ;;bcc incwx ; fall through
---
>     jmp incwx
>     ;  rts 
665,667c670,672
< ; increment a word in page zero. offset by X
< incwx:
<     lda #01
---
> ;
> ; generics 
> ;
669,678c674,677
< ; add a byte to a word in page zero. offset by X
< addwx:
<     clc
<     adc 0, x
<     sta 0, x
<     bcc @ends
<     inc 1, x
<     clc
< @ends:
<     rts
---
> spull2:
>     ldy #(snd)
>     jsr spull
>     ; fall through
679a679,687
> ;---------------------------------------------------------------------
> spull1:
>     ldy #(fst)
>     jmp spull
> 
> ;---------------------------------------------------------------------
> spush1:
>     ldy #(fst)
>     jmp spush
1134c1142
<     bne this    ; always taken
---
>     jmp this
1142c1150
<     bcc jmpnext ; always taken
---
>     jmp next
1152c1160
<     bcc jmpnext    ; always taken
---
>     jmp next
1165c1173
<     bcc keeps   ; always taken
---
>     jmp keeps
1171c1179
<     ;;clc ; cleared already
---
>     clc
1191,1192c1199,1200
<     ldx 0, y
<     stx fst + 0
---
>     lda 0, y
>     sta fst + 0
1201d1208
< jmpnext:
1210c1217,1220
<     beq isfalse  ; is \0 ?
---
>     bne istrue  ; is \0 ?
> isfalse:
>     lda #$00
>     .byte $2c   ; mask next two bytes, nice trick !
1213c1223,1225
<     bne stafst  ; always taken
---
> rest:
>     sta fst + 0
>     jmp keeps
1219,1220d1230
< isfalse:
< stafst:
1223c1233
<     beq keeps   ; always taken
---
>     jmp keeps 
1257c1267
<     sta fst + 0
---
>     sta wrd + 0
1259c1269
<     jsr wcomma
---
>     jsr tcomma
1261c1271
<     bcc next    ; always taken
---
>     jmp next
1300c1310
<     sta fst + 0
---
>     sta wrd + 0
1302c1312
<     jsr wcomma
---
>     jsr tcomma
1306c1316
<     sta fst + 0
---
>     sta wrd + 0
1308c1318
<     jsr wcomma
---
>     jsr tcomma
1311c1321
<     bcc next    ; always taken
---
>     jmp next
1353c1363
<     bcc next    ; always taken
---
>     jmp next
