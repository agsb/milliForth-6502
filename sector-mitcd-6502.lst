ca65 V2.18 - Ubuntu 2.19-1
Main file   : sector-mitcd-6502.s
Current file: sector-mitcd-6502.s

000000r 1               ;----------------------------------------------------------------------
000000r 1               ;   MilliForth for 6502
000000r 1               ;
000000r 1               ;   original for the 6502, by Alvaro G. S. Barcellos, 2023
000000r 1               ;
000000r 1               ;   https://github.com/agsb
000000r 1               ;   see the disclaimer file in this repo for more information.
000000r 1               ;
000000r 1               ;   SectorForth and MilliForth was made for x86 arch
000000r 1               ;   and uses full 16-bit registers
000000r 1               ;
000000r 1               ;   The way at 6502 is use a page zero and lots of lda/sta bytes
000000r 1               ;
000000r 1               ;   Focus in size not performance.
000000r 1               ;
000000r 1               ;   Changes:
000000r 1               ;
000000r 1               ;   all tib (80 bytes), locals (16 cells), data (36 cells) and
000000r 1               ;       return (36 cells) stacks are in page $200;
000000r 1               ;
000000r 1               ;   tib and locals grows forward, stacks grows backwards;
000000r 1               ;
000000r 1               ;   none overflow or underflow checks;
000000r 1               ;
000000r 1               ;   only immediate flag used as $80, no more flags;
000000r 1               ;
000000r 1               ;   As Forth-1994: FALSE is $0000 and TRUE is $FFFF ;
000000r 1               ;
000000r 1               ;   Remarks:
000000r 1               ;
000000r 1               ;   words must be between spaces, begin and end spaces are wise;
000000r 1               ;
000000r 1               ;   if locals not used, data stack could be 50 cells
000000r 1               ;
000000r 1               ;   For 6502:
000000r 1               ;
000000r 1               ;   * hardware stack (page $100) not used as forth stack, free for use;
000000r 1               ;
000000r 1               ;   * 6502 is a byte processor, no need 'pad' at end of even names;
000000r 1               ;
000000r 1               ;   * no multiuser, no multitask, no faster;
000000r 1               ;
000000r 1               ;   * by easy, stack operations are backwards but slightly different.
000000r 1               ;
000000r 1               ;   common: push is 'store and decrease', pull is 'increase and fetch',
000000r 1               ;
000000r 1               ;   in here: push is 'decrease and store', pull is 'fetch and increase',
000000r 1               ;
000000r 1               ;----------------------------------------------------------------------
000000r 1               ;
000000r 1               ; stuff for ca65
000000r 1               ;
000000r 1               .p02
000000r 1               .feature c_comments
000000r 1               .feature string_escapes
000000r 1               .feature org_per_seg
000000r 1               .feature dollar_is_pc
000000r 1               .feature pc_assignment
000000r 1               
000000r 1               ;---------------------------------------------------------------------
000000r 1               ; label for primitives
000000r 1               .macro makelabel arg1, arg2
000000r 1               .ident (.concat (arg1, arg2)):
000000r 1               .endmacro
000000r 1               
000000r 1               ; header for primitives
000000r 1               ; the entry point for dictionary is f_~name~
000000r 1               ; the entry point for code is ~name~
000000r 1               .macro def_word name, label, flag
000000r 1               makelabel "f_", label
000000r 1               .ident(.sprintf("H%04X", hcount + 1)) = *
000000r 1               .word .ident (.sprintf ("H%04X", hcount))
000000r 1               hcount .set hcount + 1
000000r 1               .byte .strlen(name) + flag + 0 ; nice trick !
000000r 1               .byte name
000000r 1               makelabel "", label
000000r 1               .endmacro
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               hcount .set 0
000000r 1               
000000r 1               H0000 = 0
000000r 1               
000000r 1               debug = 1
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; alias
000000r 1               
000000r 1               ; cell size
000000r 1               CELL = 2     ; two bytes, 16 bits
000000r 1               
000000r 1               ; highlander
000000r 1               FLAG_IMM = 1<<7
000000r 1               
000000r 1               ; "all in" page $200
000000r 1               
000000r 1               ; terminal input buffer, 84 bytes, forward
000000r 1               tib = $0200
000000r 1               
000000r 1               ; locals, 16 cells, forward
000000r 1               lcs = $50
000000r 1               
000000r 1               ; strange ? is a 8-bit system, look at push code ;)
000000r 1               
000000r 1               ; data stack, 36 cells, backward
000000r 1               sp0 = $B9
000000r 1               
000000r 1               ; return stack, 36 cells, backward
000000r 1               rp0 = $00
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; no values here or must be BSS
000000r 1               .segment "ZERO"
000000r 1               
000000r 1               * = $E0
0000E0  1               
0000E0  1               ; default pseudo registers
0000E0  1  00 00        nil:    .word $0 ; reserved reference offset
0000E2  1  00 00        spt:    .word $0 ; holds data stack base,
0000E4  1  00 00        rpt:    .word $0 ; holds return stack base
0000E6  1               
0000E6  1               ; inner pseudo registers for SITC
0000E6  1  00 00        lnk:    .word $0 ; link
0000E8  1  00 00        wrk:    .word $0 ; work
0000EA  1               
0000EA  1               ; scratch pseudo registers
0000EA  1  00 00        fst:    .word $0 ; first
0000EC  1  00 00        snd:    .word $0 ; second
0000EE  1  00 00        trd:    .word $0 ; third
0000F0  1               
0000F0  1               ; * = $F0
0000F0  1               
0000F0  1               ; default Forth variables
0000F0  1  00 00        state:  .word $0 ; state, only lsb used
0000F2  1  00 00        last:   .word $0 ; last link cell
0000F4  1               
0000F4  1  00 00        here:   .word $0 ; next free cell
0000F6  1  00 00        back:   .word $0 ; here while compile
0000F8  1               
0000F8  1  00 00        toin:   .word $0 ; toin, only lsb used
0000FA  1  00 00        base:   .word $0 ; base radix, define before use
0000FC  1               
0000FC  1  00 00        head:   .word $0 ; pointer to heap forward
0000FE  1  00 00        tail:   .word $0 ; pointer to heap backward
000100  1               
000100  1               ;----------------------------------------------------------------------
000100  1               ;.segment "ONCE"
000100  1               ; no rom code
000100  1               
000100  1               ;----------------------------------------------------------------------
000100  1               ;.segment "VECTORS"
000100  1               ; no boot code
000100  1               
000100  1               ;----------------------------------------------------------------------
000100  1               .segment "CODE"
000000r 1               
000000r 1               ;
000000r 1               ; leave space for page zero, hard stack,
000000r 1               ; and buffer, locals, forth stacks
000000r 1               ;
000000r 1               * = $300
000300  1               
000300  1               cold:
000300  1               ;   clear BCD
000300  1  D8               cld
000301  1               
000301  1               ;   enable interrupts
000301  1  58               cli
000302  1               
000302  1               ;   set real stack
000302  1  A2 FF            ldx #$FF
000304  1  9A               txs
000305  1               
000305  1               ; link list
000305  1  A9 05            lda #>f_exit
000307  1  85 F3            sta last + 1
000309  1  A9 B4            lda #<f_exit
00030B  1  85 F2            sta last + 0
00030D  1               
00030D  1               ; next free memory cell, must be $page aligned
00030D  1  A9 0A            lda #>init
00030F  1  85 F5            sta here + 1
000311  1  A9 00            lda #<init
000313  1  85 F4            sta here + 0
000315  1               
000315  1               ; self pointer
000315  1  A9 00            lda #>nil
000317  1  85 E1            sta nil + 1
000319  1  A9 E0            lda #<nil
00031B  1  85 E0            sta nil + 0
00031D  1               
00031D  1               ;---------------------------------------------------------------------
00031D  1               quit:
00031D  1               ; reset stacks
00031D  1  A0 02            ldy #>tib
00031F  1  84 E3            sty spt + 1
000321  1  C8               iny             ; magics !
000322  1  84 E5            sty rpt + 1
000324  1  A0 B9            ldy #<sp0
000326  1  84 E2            sty spt + 0
000328  1  A0 00            ldy #<rp0
00032A  1  84 E4            sty rpt + 0
00032C  1                   ; y == \0
00032C  1               ; clear tib stuff
00032C  1  8C 00 02         sty tib + 0
00032F  1               ; clear cursor
00032F  1  84 F8            sty toin + 0
000331  1               ; state is 'interpret' == \0
000331  1  84 F0            sty state + 0
000333  1               
000333  1               ;---------------------------------------------------------------------
000333  1               ; the outer loop
000333  1               outer:
000333  1               
000333  1               parse:
000333  1               ; get a token
000333  1  20 F0 03         jsr token
000336  1               
000336  1                   ; jsr showdic
000336  1               
000336  1               find:
000336  1               ; load last
000336  1  A5 F2            lda last + 0
000338  1  85 EE            sta trd + 0
00033A  1  A5 F3            lda last + 1
00033C  1  85 EF            sta trd + 1
00033E  1               
00033E  1               @loop:
00033E  1               ; linked list
00033E  1  A5 EE            lda trd + 0
000340  1  85 EA            sta fst + 0
000342  1               ; verify null
000342  1  05 EF            ora trd + 1
000344  1  F0 67            beq error ; end of dictionary, no more words to search, quit
000346  1               ; linked list
000346  1  A5 EF            lda trd + 1
000348  1  85 EB            sta fst + 1
00034A  1               
00034A  1               ; update link
00034A  1  A2 0A            ldx #(fst - nil) ; from
00034C  1  A0 0E            ldy #(trd - nil) ; into
00034E  1  20 47 04         jsr pull
000351  1               
000351  1               ; compare words
000351  1  A0 00            ldy #0
000353  1               ; save the flag, first byte is size plus flag
000353  1  B1 EA            lda (fst), y
000355  1  85 F1            sta state + 1
000357  1               
000357  1               @equal:
000357  1  B1 EC            lda (snd), y
000359  1               ; space ends token
000359  1  C9 20            cmp #32
00035B  1  F0 0A            beq @done
00035D  1               ; verify
00035D  1  38               sec
00035E  1  F1 EA            sbc (fst), y
000360  1               ; 7-bit ascii, also mask flag
000360  1  29 7F            and #$7F
000362  1  D0 DA            bne @loop
000364  1               ; next char
000364  1  C8               iny
000365  1  D0 F0            bne @equal
000367  1               @done:
000367  1               
000367  1               ; update fst
000367  1               
000367  1  98               tya
000368  1  A2 0A            ldx #(fst - nil)
00036A  1  20 15 04         jsr addwx
00036D  1               
00036D  1  20 4F 07         jsr showord
000370  1               
000370  1               ; repeat again
000370  1               
000370  1  A9 2E            lda #<parse_
000372  1  85 E6            sta lnk + 0
000374  1  A9 06            lda #>parse_
000376  1  85 E7            sta lnk + 1
000378  1               
000378  1               ; immediate ? if < \0
000378  1  A5 F1            lda state + 1
00037A  1  30 0F            bmi execute      ; bit 7 set
00037C  1               
00037C  1               ; executing ? if == \0
00037C  1  A5 F0            lda state + 0
00037E  1  F0 0B            beq execute
000380  1               
000380  1               compile:
000380  1                   .if debug
000380  1  A9 43            lda #'C'
000382  1  20 80 04         jsr putchar
000385  1                   .endif
000385  1               
000385  1  20 58 04         jsr copy
000388  1               
000388  1  4C D6 05         jmp next
00038B  1               
00038B  1               execute:
00038B  1                   .if debug
00038B  1  A9 45            lda #'E'
00038D  1  20 80 04         jsr putchar
000390  1                   .endif
000390  1               
000390  1  A5 EA            lda fst + 0
000392  1  85 E8            sta wrk + 0
000394  1  A5 EB            lda fst + 1
000396  1  85 E9            sta wrk + 1
000398  1               
000398  1  4C E2 05         jmp pick
00039B  1               
00039B  1               ;---------------------------------------------------------------------
00039B  1               okeys:
00039B  1  A9 4F            lda #'O'
00039D  1  20 80 04         jsr putchar
0003A0  1  A9 4B            lda #'K'
0003A2  1  20 80 04         jsr putchar
0003A5  1  A9 0A            lda #10
0003A7  1  20 80 04         jsr putchar
0003AA  1  4C 33 03         jmp parse
0003AD  1               
0003AD  1               
0003AD  1               ;---------------------------------------------------------------------
0003AD  1               error:
0003AD  1  A9 4E            lda #'N'
0003AF  1  20 80 04         jsr putchar
0003B2  1  A9 4F            lda #'O'
0003B4  1  20 80 04         jsr putchar
0003B7  1  A9 0A            lda #10
0003B9  1  20 80 04         jsr putchar
0003BC  1  4C 1D 03         jmp quit
0003BF  1               
0003BF  1               ;---------------------------------------------------------------------
0003BF  1               try:
0003BF  1  B9 00 02         lda tib, y
0003C2  1  F0 04            beq getline    ; if \0
0003C4  1  C8               iny
0003C5  1  49 20            eor #' '
0003C7  1  60               rts
0003C8  1               
0003C8  1               ;---------------------------------------------------------------------
0003C8  1               getline:
0003C8  1               ; drop rts of try
0003C8  1  68               pla
0003C9  1  68               pla
0003CA  1               
0003CA  1  A9 0A            lda #10
0003CC  1  20 80 04         jsr putchar
0003CF  1               
0003CF  1               ; leave a space
0003CF  1  A0 01            ldy #1
0003D1  1               @loop:
0003D1  1  20 7D 04         jsr getchar
0003D4  1               ;
0003D4  1               ; unix \n
0003D4  1               ;
0003D4  1  C9 0A            cmp #10
0003D6  1  F0 08            beq @ends
0003D8  1               @puts:
0003D8  1               ; 7-bit ascii, also mask flag
0003D8  1  29 7F            and #$7F
0003DA  1  99 00 02         sta tib, y
0003DD  1  C8               iny
0003DE  1  D0 F1            bne @loop
0003E0  1               ; clear all if y eq \0
0003E0  1               @ends:
0003E0  1               ; grace \b
0003E0  1  A9 20            lda #32
0003E2  1  8D 00 02         sta tib + 0 ; start with space
0003E5  1  99 00 02         sta tib, y  ; ends with space
0003E8  1               ; mark \0
0003E8  1  A9 00            lda #0
0003EA  1  C8               iny
0003EB  1  99 00 02         sta tib, y
0003EE  1               ; start it
0003EE  1  85 F8            sta toin + 0
0003F0  1               
0003F0  1               ;---------------------------------------------------------------------
0003F0  1               ;
0003F0  1               token:
0003F0  1               ; last position on tib
0003F0  1  A4 F8            ldy toin + 0
0003F2  1               @skip:
0003F2  1               ; skip spaces
0003F2  1  20 BF 03         jsr try
0003F5  1  F0 FB            beq @skip
0003F7  1               ; keep start
0003F7  1  88               dey
0003F8  1  84 F9            sty toin + 1
0003FA  1               @scan:
0003FA  1               ; scan spaces
0003FA  1  20 BF 03         jsr try
0003FD  1  D0 FB            bne @scan
0003FF  1               ; keep stop
0003FF  1  88               dey
000400  1  84 F8            sty toin + 0
000402  1               @done:
000402  1               ; sizeof
000402  1  38               sec
000403  1  98               tya
000404  1  E5 F9            sbc toin + 1
000406  1               ; keep it
000406  1  A4 F9            ldy toin + 1
000408  1  88               dey
000409  1  99 00 02         sta tib, y  ; store size ahead
00040C  1               ; setup token, pass pointer
00040C  1  84 EC            sty snd + 0
00040E  1  A9 02            lda #>tib
000410  1  85 ED            sta snd + 1
000412  1  60               rts
000413  1               
000413  1               ;---------------------------------------------------------------------
000413  1               ; increment a word in page zero, offset by X
000413  1               incwx:
000413  1  A9 01            lda #1
000415  1               ; add a byte to a word in page zero. offset by X
000415  1               addwx:
000415  1  18               clc
000416  1  75 E0            adc nil + 0, x
000418  1  95 E0            sta nil + 0, x
00041A  1  90 02            bcc @ends
00041C  1  F6 E1            inc nil + 1, x
00041E  1               @ends:
00041E  1  60               rts
00041F  1               
00041F  1               ;---------------------------------------------------------------------
00041F  1               ; decrement a word in page zero. offset by X
00041F  1               decwx:
00041F  1  B5 E0            lda nil + 0, x
000421  1  D0 02            bne @ends
000423  1  D6 E1            dec nil + 1, x
000425  1               @ends:
000425  1  D6 E0            dec nil + 0, x
000427  1  60               rts
000428  1               
000428  1               ;---------------------------------------------------------------------
000428  1               ; push a cell
000428  1               ; from a page zero address indexed by Y
000428  1               ; into a page zero indirect address indexed by X
000428  1               rpush:
000428  1  A2 04            ldx #(rpt - nil)
00042A  1  4C 2F 04         jmp push
00042D  1               
00042D  1                   ;.byte $2c   ; mask two bytes, nice trick !
00042D  1               
00042D  1               spush:
00042D  1  A2 02            ldx #(spt - nil)
00042F  1               
00042F  1               push:
00042F  1  20 1F 04         jsr decwx
000432  1  B9 E1 00         lda nil + 1, y
000435  1  81 E0            sta (nil, x)
000437  1               
000437  1  20 1F 04         jsr decwx
00043A  1  B9 E0 00         lda nil + 0, y
00043D  1  81 E0            sta (nil, x)
00043F  1               
00043F  1  60               rts
000440  1               
000440  1               ;---------------------------------------------------------------------
000440  1               ; pull a cell
000440  1               ; from a page zero indirect address indexed by X
000440  1               ; into a page zero address indexed by y
000440  1               rpull:
000440  1  A2 04            ldx #(rpt - nil)
000442  1  4C 47 04         jmp pull
000445  1               
000445  1                   ;.byte $2c   ; mask ldy, nice trick !
000445  1               
000445  1               spull:
000445  1  A2 02            ldx #(spt - nil)
000447  1               
000447  1               pull:
000447  1  A1 E0            lda (nil, x)
000449  1  99 E0 00         sta nil + 0, y
00044C  1  20 13 04         jsr incwx
00044F  1               
00044F  1  A1 E0            lda (nil, x)
000451  1  99 E1 00         sta nil + 1, y
000454  1  20 13 04         jsr incwx
000457  1               
000457  1  60               rts
000458  1               
000458  1               ;---------------------------------------------------------------------
000458  1               ; move a cell
000458  1               ; from a page zero address indexed by Y
000458  1               ; into a page zero indirect address indexed by X
000458  1               ; default case
000458  1               copy:
000458  1  A0 0A            ldy #(fst - nil)
00045A  1               each:
00045A  1  A2 14            ldx #(here - nil)
00045C  1               ;---------------------------------------------------------------------
00045C  1               ; n2z
00045C  1               poke:
00045C  1  B9 E0 00         lda nil + 0, y
00045F  1  81 E0            sta (nil,x)
000461  1  20 13 04         jsr incwx
000464  1  B9 E1 00         lda nil + 1, y
000467  1  81 E0            sta (nil, x)
000469  1  4C 13 04         jmp incwx
00046C  1               
00046C  1               ;---------------------------------------------------------------------
00046C  1               ; z2n
00046C  1               yank:
00046C  1  20 1F 04         jsr decwx
00046F  1  A1 E0            lda (nil,x)
000471  1  99 E1 00         sta nil + 1, y
000474  1  20 1F 04         jsr decwx
000477  1  81 E0            sta (nil, x)
000479  1  B9 E0 00         lda nil + 0, y
00047C  1  60               rts
00047D  1               
00047D  1               ;---------------------------------------------------------------------
00047D  1               ; for lib6502  emulator
00047D  1               ; always does echo
00047D  1               getchar:
00047D  1  AD 00 E0         lda $E000
000480  1               
000480  1               putchar:
000480  1  8D 00 E0         sta $E000
000483  1               
000483  1                   .if debug
000483  1               
000483  1               ; EOF ?
000483  1  C9 FF            cmp #$FF
000485  1  D0 12            bne rets
000487  1               
000487  1               ; return (0)
000487  1               
000487  1  A9 24            lda #'$'
000489  1  20 80 04         jsr putchar
00048C  1  A9 24            lda #'$'
00048E  1  20 80 04         jsr putchar
000491  1  A9 24            lda #'$'
000493  1  20 80 04         jsr putchar
000496  1               
000496  1  4C 00 00         jmp $0000
000499  1               
000499  1                   .endif
000499  1               
000499  1               rets:
000499  1  60               rts
00049A  1               
00049A  1               ;---------------------------------------------------------------------
00049A  1               ;
00049A  1               spull2:
00049A  1  A0 0C            ldy #(snd - nil)
00049C  1  20 45 04         jsr spull
00049F  1               
00049F  1               spull1:
00049F  1  A0 0A            ldy #(fst - nil)
0004A1  1  4C 45 04         jmp spull
0004A4  1               
0004A4  1               ;---------------------------------------------------------------------
0004A4  1               ; primitives, a address, c byte ascii, w signed word, u unsigned word
0004A4  1               ;
0004A4  1               ; ( -- c )
0004A4  1  00 00 03 6B  def_word "key", "key", 0
0004A8  1  65 79        
0004AA  1  20 7D 04         jsr getchar
0004AD  1  85 EA            sta fst + 0
0004AF  1  4C 0B 05         jmp keep
0004B2  1               
0004B2  1               ;---------------------------------------------------------------------
0004B2  1               ; ( c -- )
0004B2  1  A4 04 04 65  def_word "emit", "emit", 0
0004B6  1  6D 69 74     
0004B9  1  20 9F 04         jsr spull1
0004BC  1  A5 EA            lda fst + 0
0004BE  1  20 80 04         jsr putchar
0004C1  1  4C D6 05         jmp next
0004C4  1               
0004C4  1               ;---------------------------------------------------------------------
0004C4  1               ; ( w a -- ) ; [a] = w
0004C4  1  B2 04 01 21  def_word "!", "store", 0
0004C8  1               storew:
0004C8  1  20 9A 04         jsr spull2
0004CB  1  A2 0C            ldx #(snd - nil)
0004CD  1  A0 0A            ldy #(fst - nil)
0004CF  1  20 5C 04         jsr poke
0004D2  1  4C D6 05         jmp next
0004D5  1               
0004D5  1               ;---------------------------------------------------------------------
0004D5  1               ; ( a -- w ) ; w = [a]
0004D5  1  C4 04 01 40  def_word "@", "fetch", 0
0004D9  1               fetchw:
0004D9  1  20 9F 04         jsr spull1
0004DC  1  A2 0A            ldx #(fst - nil)
0004DE  1  A0 0C            ldy #(snd - nil)
0004E0  1  20 47 04         jsr pull
0004E3  1  4C 0D 05         jmp this
0004E6  1               
0004E6  1               ;---------------------------------------------------------------------
0004E6  1               ; ( -- rp )
0004E6  1  D5 04 03 72  def_word "rp@", "rpat", 0
0004EA  1  70 40        
0004EC  1  A2 04            ldx #(rpt - nil)
0004EE  1  4C 03 05         jmp both
0004F1  1               
0004F1  1               ;---------------------------------------------------------------------
0004F1  1               ; ( -- sp )
0004F1  1  E6 04 03 73  def_word "sp@", "spat", 0
0004F5  1  70 40        
0004F7  1  A2 02            ldx #(spt - nil)
0004F9  1  4C 03 05         jmp both
0004FC  1               
0004FC  1               ;---------------------------------------------------------------------
0004FC  1               ; ( -- state )
0004FC  1  F1 04 02 73  def_word "s@", "stat", 0
000500  1  40           
000501  1  A2 10            ldx #(state - nil)
000503  1               
000503  1               ;---------------------------------------------------------------------
000503  1               ; generic
000503  1               ;
000503  1               both:
000503  1  B5 E0            lda nil + 0, x
000505  1  85 EA            sta fst + 0
000507  1  B5 E1            lda nil + 1, x
000509  1               only:
000509  1  85 EB            sta fst + 1
00050B  1               keep:
00050B  1  A0 0A            ldy #(fst - nil)
00050D  1               this:
00050D  1  20 2D 04         jsr spush
000510  1  4C D6 05         jmp next
000513  1               
000513  1               ;---------------------------------------------------------------------
000513  1               ; ( w2 w1 -- w1 + w2 )
000513  1  FC 04 01 2B  def_word "+", "plus", 0
000517  1  20 9A 04         jsr spull2
00051A  1  18               clc
00051B  1  A5 EC            lda snd + 0
00051D  1  65 EA            adc fst + 0
00051F  1  85 EA            sta fst + 0
000521  1  A5 ED            lda snd + 1
000523  1  65 EB            adc fst + 1
000525  1  4C 09 05         jmp only
000528  1               
000528  1               ;---------------------------------------------------------------------
000528  1               ; ( w2 w1 -- NOT(w1 AND w2) )
000528  1  13 05 04 6E  def_word "nand", "nand", 0
00052C  1  61 6E 64     
00052F  1  20 9A 04         jsr spull2
000532  1  A5 EC            lda snd + 0
000534  1  25 EA            and fst + 0
000536  1  49 FF            eor #$FF
000538  1  85 EA            sta fst + 0
00053A  1  A5 ED            lda snd + 1
00053C  1  25 EB            and fst + 1
00053E  1  49 FF            eor #$FF
000540  1  4C 09 05         jmp only
000543  1               
000543  1               ;---------------------------------------------------------------------
000543  1               ; shift right
000543  1               ; ( w -- w/2 )
000543  1  28 05 02 32  def_word "2/", "asr", 0
000547  1  2F           
000548  1  20 9F 04         jsr spull1
00054B  1  46 EB            lsr fst + 1
00054D  1  66 EA            ror fst + 0
00054F  1  4C 0B 05         jmp keep
000552  1               
000552  1               ;---------------------------------------------------------------------
000552  1               ; ( 0 -- $FFFF) | ( n -- $0000)
000552  1  43 05 02 30  def_word "0#", "zeroq", 0
000556  1  23           
000557  1  20 9F 04         jsr spull1
00055A  1               ; lda fst + 1, implicit
00055A  1  05 EA            ora fst + 0
00055C  1  F0 03            beq istrue  ; is \0
00055E  1               isfalse:
00055E  1  A9 00            lda #$00
000560  1  2C               .byte $2c   ; mask two bytes, nice trick !
000561  1               istrue:
000561  1  A9 FF            lda #$FF
000563  1               rest:
000563  1  85 EA            sta fst + 0
000565  1  4C 09 05         jmp only
000568  1               
000568  1               ;---------------------------------------------------------------------
000568  1  52 05 01 3A  def_word ":", "colon", 0
00056C  1               ; save here, panic if semis not follow elsewhere
00056C  1  A5 F4            lda here + 0
00056E  1  85 F6            sta back + 0 ; pha
000570  1  A5 F5            lda here + 1
000572  1  85 F7            sta back + 1 ; pha
000574  1               ; state is 'compile'
000574  1  A9 01            lda #1
000576  1  85 F0            sta state + 0
000578  1               
000578  1               create:
000578  1               ; link last into (here)
000578  1  A0 12            ldy #(last - nil)
00057A  1  20 5A 04         jsr each
00057D  1               ; get token
00057D  1  20 F0 03         jsr token
000580  1               ; copy size and name
000580  1  A0 00            ldy #0
000582  1               @loop:
000582  1  B1 EC            lda (snd), y
000584  1  C9 20            cmp #32    ; stops at space
000586  1  F0 05            beq @ends
000588  1  91 F4            sta (here), y
00058A  1  C8               iny
00058B  1  D0 F5            bne @loop
00058D  1               @ends:
00058D  1               
00058D  1               ; update here
00058D  1  98               tya
00058E  1  A2 14            ldx #(here - nil)
000590  1  20 15 04         jsr addwx
000593  1               
000593  1               
000593  1               ; att: address in data, here updated
000593  1  4C D6 05         jmp next
000596  1               
000596  1               ;---------------------------------------------------------------------
000596  1  68 05 81 3B  def_word ";", "semis", FLAG_IMM
00059A  1               ; update last, panic if comma not lead
00059A  1  A5 F7            lda back + 1 ; pla
00059C  1  85 F3            sta last + 1
00059E  1  A5 F6            lda back + 0 ; pla
0005A0  1  85 F2            sta last + 0
0005A2  1               ; state is 'interpret'
0005A2  1  A9 00            lda #0
0005A4  1  85 F0            sta state + 0
0005A6  1               
0005A6  1               ; compounds words must ends with 'unnest'
0005A6  1  A9 BB            lda #<unnest
0005A8  1  85 EA            sta fst + 0
0005AA  1  A9 05            lda #>unnest
0005AC  1  85 EB            sta fst + 1
0005AE  1               
0005AE  1  20 70 06         jsr showdic
0005B1  1               
0005B1  1  4C 80 03         jmp compile
0005B4  1               
0005B4  1               ;---------------------------------------------------------------------
0005B4  1               ; NON classic direct thread code
0005B4  1               ;   lnk is IP, wrk is W
0005B4  1               ;
0005B4  1               ; using MITC, minimum indirect thread code
0005B4  1               ;
0005B4  1  96 05 04 65  def_word "exit", "exit", 0
0005B8  1  78 69 74     
0005BB  1               inner:
0005BB  1               
0005BB  1               unnest:
0005BB  1                   .if debug
0005BB  1  A9 55            lda #'U'
0005BD  1  20 80 04         jsr putchar
0005C0  1                   .endif
0005C0  1               
0005C0  1  20 98 07         jsr dumpnil
0005C3  1               
0005C3  1               ; pull
0005C3  1  A0 06            ldy #(lnk - nil)
0005C5  1  20 40 04         jsr rpull
0005C8  1               
0005C8  1  20 98 07         jsr dumpnil
0005CB  1               
0005CB  1  20 A1 08         jsr dumpr
0005CE  1               
0005CE  1  20 CF 08         jsr dumps
0005D1  1               
0005D1  1  A9 0A            lda #10
0005D3  1  20 80 04         jsr putchar
0005D6  1               
0005D6  1               next:
0005D6  1                   .if debug
0005D6  1  A9 58            lda #'X'
0005D8  1  20 80 04         jsr putchar
0005DB  1                   .endif
0005DB  1               
0005DB  1               ; wrk = (lnk) ; lnk = lnk + 2
0005DB  1  A2 06            ldx #(lnk - nil)
0005DD  1  A0 08            ldy #(wrk - nil)
0005DF  1  20 47 04         jsr pull
0005E2  1               
0005E2  1                   ;.if debug
0005E2  1                   ;jsr dump
0005E2  1                   ;.endif
0005E2  1               
0005E2  1               pick:
0005E2  1                   .if debug
0005E2  1  A9 50            lda #'P'
0005E4  1  20 80 04         jsr putchar
0005E7  1                   .endif
0005E7  1               
0005E7  1               
0005E7  1               ; minimal
0005E7  1  A5 E9            lda wrk + 1
0005E9  1  C9 0A            cmp #>init
0005EB  1  30 35            bmi jump
0005ED  1               
0005ED  1               nest:
0005ED  1                   .if debug
0005ED  1  A9 4E            lda #'N'
0005EF  1  20 80 04         jsr putchar
0005F2  1                   .endif
0005F2  1               
0005F2  1  20 98 07         jsr dumpnil
0005F5  1               
0005F5  1  A2 06            ldx #(lnk - nil)
0005F7  1  A9 02            lda #2
0005F9  1  20 15 04         jsr addwx
0005FC  1               
0005FC  1  20 98 07         jsr dumpnil
0005FF  1               
0005FF  1               ; push into return stack
0005FF  1  A0 06            ldy #(lnk - nil)
000601  1  20 28 04         jsr rpush
000604  1               
000604  1  20 98 07         jsr dumpnil
000607  1               
000607  1  20 A1 08         jsr dumpr
00060A  1               
00060A  1  20 CF 08         jsr dumps
00060D  1               
00060D  1  A9 0A            lda #10
00060F  1  20 80 04         jsr putchar
000612  1               
000612  1               link:
000612  1                   .if debug
000612  1  A9 4C            lda #'L'
000614  1  20 80 04         jsr putchar
000617  1                   .endif
000617  1               
000617  1  A5 E8            lda wrk + 0
000619  1  85 E6            sta lnk + 0
00061B  1  A5 E9            lda wrk + 1
00061D  1  85 E7            sta lnk + 1
00061F  1               
00061F  1  4C D6 05         jmp next
000622  1               
000622  1               ; historical JMP @(W)+
000622  1               jump:
000622  1                   .if debug
000622  1  A9 4A            lda #'J'
000624  1  20 80 04         jsr putchar
000627  1                   .endif
000627  1               
000627  1  6C E8 00         jmp (wrk)
00062A  1               
00062A  1               ;---------------------------------------------------------------------
00062A  1               ; pseudo
00062A  1               ;
00062A  1               docol_:
00062A  1  ED 05            .word nest
00062C  1               
00062C  1               semis_:
00062C  1  BB 05            .word unnest
00062E  1               
00062E  1               parse_:
00062E  1  33 03            .word parse
000630  1               
000630  1               ends:
000630  1               
000630  1               ;---------------------------------------------------------------------
000630  1               
000630  1               ; debug stuff
000630  1               .if debug
000630  1               
000630  1               ;----------------------------------------------------------------------
000630  1               .macro saveregs
000630  1                   php
000630  1                   pha
000630  1                   tya
000630  1                   pha
000630  1                   txa
000630  1                   pha
000630  1               .endmacro
000630  1               
000630  1               ;----------------------------------------------------------------------
000630  1               .macro loadregs
000630  1                   pla
000630  1                   tax
000630  1                   pla
000630  1                   tay
000630  1                   pla
000630  1                   plp
000630  1               .endmacro
000630  1               
000630  1               ;----------------------------------------------------------------------
000630  1               savenils:
000630  1  A0 00            ldy #0
000632  1               @loop:
000632  1  B9 E0 00         lda $00E0, y
000635  1  99 C0 00         sta $00C0, y
000638  1  C8               iny
000639  1  C0 10            cpy #16
00063B  1  D0 F5            bne @loop
00063D  1  60               rts
00063E  1               
00063E  1               ;----------------------------------------------------------------------
00063E  1               loadnils:
00063E  1  A0 00            ldy #0
000640  1               @loop:
000640  1  B9 C0 00         lda $00C0, y
000643  1  99 E0 00         sta $00E0, y
000646  1  C8               iny
000647  1  C0 10            cpy #16
000649  1  D0 F5            bne @loop
00064B  1  60               rts
00064C  1               
00064C  1               ;----------------------------------------------------------------------
00064C  1               erro:
00064C  1  48               pha
00064D  1  A9 3F            lda #'?'
00064F  1  20 80 04         jsr putchar
000652  1  A9 3F            lda #'?'
000654  1  20 80 04         jsr putchar
000657  1  A9 0A            lda #10
000659  1  20 80 04         jsr putchar
00065C  1  68               pla
00065D  1  60               rts
00065E  1               
00065E  1               okey:
00065E  1  48               pha
00065F  1  A9 4F            lda #'O'
000661  1  20 80 04         jsr putchar
000664  1  A9 4B            lda #'K'
000666  1  20 80 04         jsr putchar
000669  1  A9 0A            lda #10
00066B  1  20 80 04         jsr putchar
00066E  1  68               pla
00066F  1  60               rts
000670  1               
000670  1               ;---------------------------------------------------------------------
000670  1               showdic:
000670  1               
000670  1  08 48 98 48      saveregs
000674  1  8A 48        
000676  1               
000676  1  20 30 06         jsr savenils
000679  1               
000679  1  A9 0A            lda #10
00067B  1  20 80 04         jsr putchar
00067E  1               
00067E  1  A9 7B            lda #'{'
000680  1  20 80 04         jsr putchar
000683  1               
000683  1  A9 0A            lda #10
000685  1  20 80 04         jsr putchar
000688  1               
000688  1               ; load lastest link
000688  1  A5 F2            lda last + 0
00068A  1  85 EE            sta trd + 0
00068C  1  A5 F3            lda last + 1
00068E  1  85 EF            sta trd + 1
000690  1               
000690  1               @loop:
000690  1               
000690  1               ; update link list
000690  1  A5 EE            lda trd + 0
000692  1  85 EA            sta fst + 0
000694  1               
000694  1               ; verify is zero
000694  1  05 EF            ora trd + 1
000696  1  F0 3F            beq @ends ; end of dictionary, no more words to search, quit
000698  1               
000698  1               ; update link list
000698  1  A5 EF            lda trd + 1
00069A  1  85 EB            sta fst + 1
00069C  1               
00069C  1  A9 7E            lda #'~'
00069E  1  20 80 04         jsr putchar
0006A1  1  A5 EB            lda fst + 1
0006A3  1  20 4F 09         jsr puthex
0006A6  1  A5 EA            lda fst + 0
0006A8  1  20 4F 09         jsr puthex
0006AB  1               
0006AB  1               ; get that link, wrk = [fst]
0006AB  1               ; bypass the link fst+2
0006AB  1  A2 0A            ldx #(fst - nil) ; from
0006AD  1  A0 0E            ldy #(trd - nil) ; into
0006AF  1  20 47 04         jsr pull
0006B2  1               
0006B2  1  A9 23            lda #'#'
0006B4  1  20 80 04         jsr putchar
0006B7  1               
0006B7  1  A0 00            ldy #0
0006B9  1  B1 EA            lda (fst), y
0006BB  1  29 7F            and #$7F
0006BD  1  AA               tax
0006BE  1  20 4F 09         jsr puthex
0006C1  1               
0006C1  1  A9 20            lda #' '
0006C3  1  20 80 04         jsr putchar
0006C6  1               
0006C6  1               @loopa:
0006C6  1  C8               iny
0006C7  1  B1 EA            lda (fst), y
0006C9  1  20 80 04         jsr putchar
0006CC  1  CA               dex
0006CD  1  D0 F7            bne @loopa
0006CF  1               
0006CF  1  A9 0A            lda #10
0006D1  1  20 80 04         jsr putchar
0006D4  1               
0006D4  1  4C 90 06         jmp @loop
0006D7  1               
0006D7  1               @ends:
0006D7  1               
0006D7  1  A9 7D            lda #'}'
0006D9  1  20 80 04         jsr putchar
0006DC  1               
0006DC  1  A9 0A            lda #10
0006DE  1  20 80 04         jsr putchar
0006E1  1               
0006E1  1  20 3E 06         jsr loadnils
0006E4  1               
0006E4  1  68 AA 68 A8      loadregs
0006E8  1  68 28        
0006EA  1               
0006EA  1  60               rts
0006EB  1               
0006EB  1               ;----------------------------------------------------------------------
0006EB  1               ; show state
0006EB  1               showsts:
0006EB  1               
0006EB  1  A9 20            lda #' '
0006ED  1  20 80 04         jsr putchar
0006F0  1               
0006F0  1  A5 F0            lda state + 0
0006F2  1  20 4F 09         jsr puthex
0006F5  1               
0006F5  1  60               rts
0006F6  1               
0006F6  1               ;----------------------------------------------------------------------
0006F6  1               ; show here
0006F6  1               showhere:
0006F6  1               
0006F6  1  A9 20            lda #' '
0006F8  1  20 80 04         jsr putchar
0006FB  1               
0006FB  1  A5 F5            lda here + 1
0006FD  1  20 4F 09         jsr puthex
000700  1               
000700  1  A5 F4            lda here + 0
000702  1  20 4F 09         jsr puthex
000705  1               
000705  1  60               rts
000706  1               
000706  1               ;----------------------------------------------------------------------
000706  1               ; show last
000706  1               showlast:
000706  1               
000706  1  A9 20            lda #' '
000708  1  20 80 04         jsr putchar
00070B  1               
00070B  1  A5 F3            lda last + 1
00070D  1  20 4F 09         jsr puthex
000710  1               
000710  1  A5 F2            lda last + 0
000712  1  20 4F 09         jsr puthex
000715  1               
000715  1  60               rts
000716  1               
000716  1               ;----------------------------------------------------------------------
000716  1               ; show lst
000716  1               showfst:
000716  1               
000716  1  A9 20            lda #' '
000718  1  20 80 04         jsr putchar
00071B  1               
00071B  1  A5 EB            lda fst + 1
00071D  1  20 4F 09         jsr puthex
000720  1               
000720  1  A5 EA            lda fst + 0
000722  1  20 4F 09         jsr puthex
000725  1               
000725  1  60               rts
000726  1               
000726  1               ;----------------------------------------------------------------------
000726  1               showname:
000726  1               
000726  1               ; search backwards
000726  1               
000726  1  A2 0A            ldx #(fst - nil)
000728  1               
000728  1               @loop1:
000728  1  20 1F 04         jsr decwx
00072B  1  A1 E0            lda (nil, x)
00072D  1  48               pha
00072E  1  29 7F            and #$7F
000730  1  C9 20            cmp #' '
000732  1  10 F4            bpl @loop1
000734  1               
000734  1               ; show size+flag
000734  1               
000734  1  A9 20            lda #' '
000736  1  20 80 04         jsr putchar
000739  1               
000739  1               ; size
000739  1  68               pla
00073A  1  48               pha
00073B  1  20 4F 09         jsr puthex
00073E  1               
00073E  1               ; mask flag
00073E  1               
00073E  1  68               pla
00073F  1  29 7F            and #$7F
000741  1  A8               tay
000742  1               
000742  1               ; show name
000742  1               
000742  1  A9 20            lda #' '
000744  1  20 80 04         jsr putchar
000747  1               
000747  1               @loop2:
000747  1  68               pla
000748  1  20 80 04         jsr putchar
00074B  1  88               dey
00074C  1  D0 F9            bne @loop2
00074E  1               
00074E  1  60               rts
00074F  1               
00074F  1               ;----------------------------------------------------------------------
00074F  1               showord:
00074F  1               
00074F  1  08 48 98 48      saveregs
000753  1  8A 48        
000755  1               
000755  1  20 30 06         jsr savenils
000758  1               
000758  1               @start:
000758  1               
000758  1  A9 0A            lda #10
00075A  1  20 80 04         jsr putchar
00075D  1               
00075D  1  A9 28            lda #'('
00075F  1  20 80 04         jsr putchar
000762  1               
000762  1  20 EB 06         jsr showsts
000765  1               
000765  1  20 F6 06         jsr showhere
000768  1               
000768  1  20 06 07         jsr showlast
00076B  1               
00076B  1  20 16 07         jsr showfst
00076E  1               
00076E  1  20 26 07         jsr showname
000771  1               
000771  1  A9 20            lda #' '
000773  1  20 80 04         jsr putchar
000776  1               
000776  1               ; show list
000776  1               
000776  1  A5 EB            lda fst + 1
000778  1  C9 0A            cmp #>init
00077A  1  30 00            bmi @ends
00077C  1               
00077C  1               ; only compiled
00077C  1               
00077C  1                   ; jsr alist
00077C  1               
00077C  1               @ends:
00077C  1               
00077C  1  A9 29            lda #')'
00077E  1  20 80 04         jsr putchar
000781  1               
000781  1                   ; jsr dump
000781  1               
000781  1                   ; jsr dumps
000781  1               
000781  1                   ; jsr dumpr
000781  1               
000781  1  20 3E 06         jsr loadnils
000784  1               
000784  1  68 AA 68 A8      loadregs
000788  1  68 28        
00078A  1               
00078A  1  60               rts
00078B  1               
00078B  1               
00078B  1               ;----------------------------------------------------------------------
00078B  1               
00078B  1               showstk:
00078B  1               
00078B  1  A9 20            lda #' '
00078D  1  20 80 04         jsr putchar
000790  1               
000790  1  BA               tsx
000791  1  E8               inx
000792  1  E8               inx
000793  1  8A               txa
000794  1  20 4F 09         jsr puthex
000797  1               
000797  1  60               rts
000798  1               
000798  1               ;----------------------------------------------------------------------
000798  1               dumpnil:
000798  1               
000798  1  08               php
000799  1  48               pha
00079A  1  98               tya
00079B  1  48               pha
00079C  1  8A               txa
00079D  1  48               pha
00079E  1               
00079E  1  A9 0A            lda #10
0007A0  1  20 80 04         jsr putchar
0007A3  1  A9 3D            lda #'='
0007A5  1  20 80 04         jsr putchar
0007A8  1               
0007A8  1  A0 00            ldy #0
0007AA  1               @loop:
0007AA  1  A9 20            lda #' '
0007AC  1  20 80 04         jsr putchar
0007AF  1  B9 E1 00         lda nil+1, y
0007B2  1  20 4F 09         jsr puthex
0007B5  1  B9 E0 00         lda nil+0, y
0007B8  1  20 4F 09         jsr puthex
0007BB  1  C8               iny
0007BC  1  C8               iny
0007BD  1               
0007BD  1  C0 10            cpy #16
0007BF  1  D0 0A            bne @byes
0007C1  1  A9 20            lda #' '
0007C3  1  20 80 04         jsr putchar
0007C6  1  A9 5F            lda #'_'
0007C8  1  20 80 04         jsr putchar
0007CB  1               
0007CB  1               @byes:
0007CB  1  C0 20            cpy #32
0007CD  1  D0 DB            bne @loop
0007CF  1               
0007CF  1  68               pla
0007D0  1  AA               tax
0007D1  1  68               pla
0007D2  1  A8               tay
0007D3  1  68               pla
0007D4  1  28               plp
0007D5  1               
0007D5  1  60               rts
0007D6  1               
0007D6  1               ;----------------------------------------------------------------------
0007D6  1               dumpext:
0007D6  1               
0007D6  1  48               pha
0007D7  1               
0007D7  1  A9 0A            lda #10
0007D9  1  20 80 04         jsr putchar
0007DC  1               
0007DC  1  A9 7B            lda #'{'
0007DE  1  20 80 04         jsr putchar
0007E1  1               
0007E1  1  A9 20            lda #' '
0007E3  1  20 80 04         jsr putchar
0007E6  1  A9 48            lda #'H'
0007E8  1  20 80 04         jsr putchar
0007EB  1  A9 3D            lda #'='
0007ED  1  20 80 04         jsr putchar
0007F0  1  A5 F5            lda here + 1
0007F2  1  20 4F 09         jsr puthex
0007F5  1  A5 F4            lda here + 0
0007F7  1  20 4F 09         jsr puthex
0007FA  1               
0007FA  1  A9 20            lda #' '
0007FC  1  20 80 04         jsr putchar
0007FF  1  A9 4C            lda #'L'
000801  1  20 80 04         jsr putchar
000804  1  A9 3D            lda #'='
000806  1  20 80 04         jsr putchar
000809  1  A5 E7            lda lnk + 1
00080B  1  20 4F 09         jsr puthex
00080E  1  A5 E6            lda lnk + 0
000810  1  20 4F 09         jsr puthex
000813  1               
000813  1  A9 20            lda #' '
000815  1  20 80 04         jsr putchar
000818  1  A9 57            lda #'W'
00081A  1  20 80 04         jsr putchar
00081D  1  A9 3D            lda #'='
00081F  1  20 80 04         jsr putchar
000822  1  A5 E9            lda wrk + 1
000824  1  20 4F 09         jsr puthex
000827  1  A5 E8            lda wrk + 0
000829  1  20 4F 09         jsr puthex
00082C  1               
00082C  1  A9 20            lda #' '
00082E  1  20 80 04         jsr putchar
000831  1  A9 53            lda #'S'
000833  1  20 80 04         jsr putchar
000836  1  A9 3D            lda #'='
000838  1  20 80 04         jsr putchar
00083B  1  A5 E3            lda spt + 1
00083D  1  20 4F 09         jsr puthex
000840  1  A5 E2            lda spt + 0
000842  1  20 4F 09         jsr puthex
000845  1               
000845  1  A9 20            lda #' '
000847  1  20 80 04         jsr putchar
00084A  1  A9 52            lda #'R'
00084C  1  20 80 04         jsr putchar
00084F  1  A9 3D            lda #'='
000851  1  20 80 04         jsr putchar
000854  1  A5 E5            lda rpt + 1
000856  1  20 4F 09         jsr puthex
000859  1  A5 E4            lda rpt + 0
00085B  1  20 4F 09         jsr puthex
00085E  1               
00085E  1  A9 7D            lda #'}'
000860  1  20 80 04         jsr putchar
000863  1               
000863  1  A9 0A            lda #10
000865  1  20 80 04         jsr putchar
000868  1               
000868  1  68               pla
000869  1               
000869  1  60               rts
00086A  1               
00086A  1               ;----------------------------------------------------------------------
00086A  1               ; show hard stack
00086A  1               dumpk:
00086A  1               
00086A  1  08               php
00086B  1  48               pha
00086C  1  8A               txa
00086D  1  48               pha
00086E  1  98               tya
00086F  1  48               pha
000870  1               
000870  1  BA               tsx
000871  1               
000871  1  A9 53            lda #'S'
000873  1  20 80 04         jsr putchar
000876  1  8A               txa
000877  1  20 4F 09         jsr puthex
00087A  1               
00087A  1  A9 20            lda #' '
00087C  1  20 80 04         jsr putchar
00087F  1               
00087F  1  E8               inx
000880  1  E8               inx
000881  1  E8               inx
000882  1  E8               inx
000883  1               
000883  1               @loop:
000883  1               
000883  1  8A               txa
000884  1  20 4F 09         jsr puthex
000887  1  A9 3A            lda #':'
000889  1  20 80 04         jsr putchar
00088C  1  BD 00 01         lda $100, x
00088F  1  20 4F 09         jsr puthex
000892  1  A9 20            lda #' '
000894  1  20 80 04         jsr putchar
000897  1  E8               inx
000898  1  D0 E9            bne @loop
00089A  1               
00089A  1  68               pla
00089B  1  A8               tay
00089C  1  68               pla
00089D  1  AA               tax
00089E  1  68               pla
00089F  1  28               plp
0008A0  1               
0008A0  1  60               rts
0008A1  1               
0008A1  1               ;----------------------------------------------------------------------
0008A1  1               dumpr:
0008A1  1               
0008A1  1  A9 0A            lda #10
0008A3  1  20 80 04         jsr putchar
0008A6  1               
0008A6  1  A9 52            lda #'R'
0008A8  1  20 80 04         jsr putchar
0008AB  1               
0008AB  1  A9 20            lda #' '
0008AD  1  20 80 04         jsr putchar
0008B0  1               
0008B0  1  38               sec
0008B1  1  A9 00            lda #rp0
0008B3  1  E5 E4            sbc rpt + 0
0008B5  1  F0 17            beq @ends
0008B7  1  A8               tay
0008B8  1               
0008B8  1               @rloop:
0008B8  1  A9 20            lda #' '
0008BA  1  20 80 04         jsr putchar
0008BD  1               
0008BD  1  98               tya
0008BE  1  20 4F 09         jsr puthex
0008C1  1               
0008C1  1  A9 3D            lda #'='
0008C3  1  20 80 04         jsr putchar
0008C6  1               
0008C6  1  B1 E4            lda (rpt), y
0008C8  1  20 4F 09         jsr puthex
0008CB  1               
0008CB  1  88               dey
0008CC  1  D0 EA            bne @rloop
0008CE  1               
0008CE  1               @ends:
0008CE  1               
0008CE  1  60               rts
0008CF  1               
0008CF  1               ;----------------------------------------------------------------------
0008CF  1               dumps:
0008CF  1               
0008CF  1  A9 0A            lda #10
0008D1  1  20 80 04         jsr putchar
0008D4  1               
0008D4  1  A9 53            lda #'S'
0008D6  1  20 80 04         jsr putchar
0008D9  1               
0008D9  1  A9 20            lda #' '
0008DB  1  20 80 04         jsr putchar
0008DE  1               
0008DE  1  38               sec
0008DF  1  A9 B9            lda #sp0
0008E1  1  E5 E2            sbc spt + 0
0008E3  1  F0 17            beq @ends
0008E5  1  A8               tay
0008E6  1               
0008E6  1               @sloop:
0008E6  1  A9 20            lda #' '
0008E8  1  20 80 04         jsr putchar
0008EB  1               
0008EB  1  98               tya
0008EC  1  20 4F 09         jsr puthex
0008EF  1               
0008EF  1  A9 3D            lda #'='
0008F1  1  20 80 04         jsr putchar
0008F4  1               
0008F4  1  B1 E2            lda (spt) , y
0008F6  1  20 4F 09         jsr puthex
0008F9  1               
0008F9  1  88               dey
0008FA  1  D0 EA            bne @sloop
0008FC  1               
0008FC  1               @ends:
0008FC  1               
0008FC  1  60               rts
0008FD  1               
0008FD  1               
0008FD  1               ;----------------------------------------------------------------------
0008FD  1               ; show compiled list address
0008FD  1               ;
0008FD  1               alist:
0008FD  1               
0008FD  1  A0 00            ldy #$0
0008FF  1               
0008FF  1               @loop:
0008FF  1  A9 20            lda #' '
000901  1  20 80 04         jsr putchar
000904  1               
000904  1               ; view
000904  1  B1 EA            lda (fst), y
000906  1  85 E8            sta wrk + 0
000908  1  C8               iny
000909  1  B1 EA            lda (fst), y
00090B  1  85 E9            sta wrk + 1
00090D  1  C8               iny
00090E  1               
00090E  1               ; show
00090E  1  A5 E9            lda wrk + 1
000910  1  20 4F 09         jsr puthex
000913  1  A5 E8            lda wrk + 0
000915  1  20 4F 09         jsr puthex
000918  1               
000918  1               ; stop
000918  1  A5 E8            lda wrk + 0
00091A  1  C9 BB            cmp #<unnest
00091C  1  D0 E1            bne @loop
00091E  1  A5 E9            lda wrk + 1
000920  1  C9 05            cmp #>unnest
000922  1  D0 DB            bne @loop
000924  1               
000924  1               @ends:
000924  1               
000924  1  60               rts
000925  1               
000925  1               ;----------------------------------------------------------------------
000925  1               ; value:offset
000925  1               ilist:
000925  1  20 4F 09         jsr puthex
000928  1  A9 3A            lda #':'
00092A  1  20 80 04         jsr putchar
00092D  1  98               tya
00092E  1  20 4F 09         jsr puthex
000931  1  A9 20            lda #' '
000933  1  20 80 04         jsr putchar
000936  1  60               rts
000937  1               
000937  1               ;----------------------------------------------------------------------
000937  1               ; dumps terminal input buffer
000937  1               showtib:
000937  1  A9 5F            lda #'_'
000939  1  20 80 04         jsr putchar
00093C  1  A0 00            ldy #0
00093E  1                   @loop:
00093E  1  B9 00 02         lda tib, y
000941  1  F0 06            beq @done
000943  1  20 80 04         jsr putchar
000946  1  C8               iny
000947  1  D0 F5            bne @loop
000949  1                   @done:
000949  1  A9 5F            lda #'_'
00094B  1  20 80 04         jsr putchar
00094E  1  60               rts
00094F  1               
00094F  1               ;----------------------------------------------------------------------
00094F  1               ; print a 8-bit HEX
00094F  1               puthex:
00094F  1  48               pha
000950  1  4A               lsr
000951  1  6A               ror
000952  1  6A               ror
000953  1  6A               ror
000954  1  20 58 09         jsr @conv
000957  1  68               pla
000958  1               @conv:
000958  1  29 0F            and #$0F
00095A  1  18               clc
00095B  1  09 30            ora #$30
00095D  1  C9 3A            cmp #$3A
00095F  1  90 02            bcc @ends
000961  1  69 06            adc #$06
000963  1               @ends:
000963  1  4C 80 04         jmp putchar
000966  1               
000966  1               ;----------------------------------------------------------------------
000966  1               .endif
000966  1               
000966  1               ; for anything above is not a primitive
000966  1  xx xx xx xx  .align $100
00096A  1  xx xx xx xx  
00096E  1  xx xx xx xx  
000A00  1               
000A00  1               init:
000A00  1               
000A00  1               
000A00  1               
