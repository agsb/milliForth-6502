ca65 V2.19 - Git 5537b61e6
Main file   : sector-6502.s
Current file: sector-6502.s

000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ;   MilliForth for 6502
000000r 1               ;
000000r 1               ;   original for the 6502, by Alvaro G. S. Barcellos, 2023
000000r 1               ;
000000r 1               ;   https://github.com/agsb
000000r 1               ;   see the disclaimer file in this repo for more information.
000000r 1               ;
000000r 1               ;   SectorForth and MilliForth was made for x86 arch
000000r 1               ;   and uses full 16-bit registers
000000r 1               ;
000000r 1               ;   The way at 6502 is use a page zero and lots of lda/sta bytes
000000r 1               ;
000000r 1               ;   Focus in size not performance.
000000r 1               ;
000000r 1               ;   Changes:
000000r 1               ;   data and return stacks and tib are 256 bytes
000000r 1               ;   only immediate flag used as $80, no hide, no compile, no extras
000000r 1               ;
000000r 1               ;   Forth-1994:
000000r 1               ;   FALSE is $0000
000000r 1               ;   TRUE  is $FFFF
000000r 1               ;
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; for ca65
000000r 1               .p02
000000r 1               .feature c_comments
000000r 1               .feature string_escapes
000000r 1               .feature org_per_seg
000000r 1               .feature dollar_is_pc
000000r 1               .feature pc_assignment
000000r 1               
000000r 1               ;---------------------------------------------------------------------
000000r 1               ; label for primitives
000000r 1               .macro makelabel arg1, arg2
000000r 1               .ident (.concat (arg1, arg2)):
000000r 1               .endmacro
000000r 1               
000000r 1               H0000 = 0
000000r 1               hcount .set 0
000000r 1               
000000r 1               ; header for primitives
000000r 1               .macro def_word name, label, flag
000000r 1               ;this = *
000000r 1               makelabel "is_", label
000000r 1                   .ident(.sprintf("H%04X", hcount + 1)) = *
000000r 1                   .word .ident (.sprintf ("H%04X", hcount))
000000r 1                   hcount .set hcount + 1
000000r 1                   .byte .strlen(name) + flag + 0
000000r 1                   .byte name
000000r 1               makelabel "", label
000000r 1               .endmacro
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; alias
000000r 1               
000000r 1               CELL   =  2     ; 16 bits
000000r 1               
000000r 1               SIZES  = $100
000000r 1               
000000r 1               FLAG_IMM  =  1<<7
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               .segment "ZERO"
000000r 1               
000000r 1               * = $E0
0000E0  1               ; default pseudo registers
0000E0  1  00 00        nil:    .word $0 ; reference, do not touch !
0000E2  1  00 00        lnk:    .word $0 ; link, do not touch !
0000E4  1  00 00        dta:    .word $0 ; holds data stack base,
0000E6  1  00 00        ret:    .word $0 ; holds return stack base,
0000E8  1               
0000E8  1               ; default Forth pseudo registers
0000E8  1  00 00        tos:    .word $0 ; top
0000EA  1  00 00        nos:    .word $0 ; nos
0000EC  1  00 00        wrk:    .word $0 ; work
0000EE  1  00 00        tmp:    .word $0 ; temp
0000F0  1               
0000F0  1               ; default Forth variables
0000F0  1  00 00        state:  .word $0 ; state
0000F2  1  00 00        toin:   .word $0 ; toin
0000F4  1  00 00        last:   .word $0 ; last link cell
0000F6  1  00 00        here:   .word $0 ; next free cell
0000F8  1               
0000F8  1               ;----------------------------------------------------------------------
0000F8  1               ;.segment "ONCE"
0000F8  1               
0000F8  1               ;----------------------------------------------------------------------
0000F8  1               ;.segment "VECTORS"
0000F8  1               
0000F8  1               ;----------------------------------------------------------------------
0000F8  1               .segment "CODE"
000000r 1               
000000r 1               ;---------------------------------------------------------------------
000000r 1               main:
000000r 1               
000000r 1                   ; latest link
000000r 1  A9 rr            lda #<semis
000002r 1  85 F4            sta last + 0
000004r 1  A9 rr            lda #>semis
000006r 1  85 F5            sta last + 1
000008r 1               
000008r 1                   ; next free memory cell
000008r 1  A9 rr            lda #<init
00000Ar 1  85 F6            sta here + 0
00000Cr 1  A9 rr            lda #>init
00000Er 1  85 F7            sta here + 1
000010r 1               
000010r 1                   ; that does the trick
000010r 1  A9 E0            lda #<nil
000012r 1  85 E0            sta nil + 0
000014r 1  A9 00            lda #>nil
000016r 1  85 E1            sta nil + 1
000018r 1               
000018r 1               error:
000018r 1               
000018r 1  A9 0D            lda #13
00001Ar 1  20 rr rr         jsr putchar
00001Dr 1               
00001Dr 1               ;---------------------------------------------------------------------
00001Dr 1               quit:
00001Dr 1               
00001Dr 1                   ; reset data stack
00001Dr 1  A0 rr            ldy #>dsb
00001Fr 1  84 E5            sty dta + 1
000021r 1               
000021r 1                   ; reset return stack
000021r 1  A0 rr            ldy #>rsb
000023r 1  84 E7            sty ret + 1
000025r 1               
000025r 1                   ; start at page
000025r 1  A0 00            ldy #0
000027r 1  84 E4            sty dta + 0
000029r 1  84 E6            sty ret + 0
00002Br 1               
00002Br 1                   ; clear tib stuff
00002Br 1  84 F2            sty toin + 0
00002Dr 1  84 F3            sty toin + 1
00002Fr 1  8C rr rr         sty tib + 0
000032r 1               
000032r 1                   ; state is 'interpret'
000032r 1  C8               iny
000033r 1  84 F0            sty state + 0
000035r 1               
000035r 1               ;---------------------------------------------------------------------
000035r 1               outer:
000035r 1               
000035r 1                   ; magic loop
000035r 1  A9 rr            lda #<outer
000037r 1  85 E2            sta lnk + 0
000039r 1  A9 rr            lda #>outer
00003Br 1  85 E3            sta lnk + 1
00003Dr 1               
00003Dr 1                   ; get a token, (nos)
00003Dr 1  20 rr rr         jsr token
000040r 1               
000040r 1               find:
000040r 1                   ; load lastest link
000040r 1  A9 F4            lda #<last
000042r 1  85 EC            sta wrk + 0
000044r 1  A9 00            lda #>last
000046r 1  85 ED            sta wrk + 1
000048r 1               
000048r 1               @loop:
000048r 1               
000048r 1                   ; update link list
000048r 1  A5 EC            lda wrk + 0
00004Ar 1  85 E8            sta tos + 0
00004Cr 1               
00004Cr 1                   ; verify is zero
00004Cr 1  05 ED            ora wrk + 1
00004Er 1  F0 C8            beq error ; end of dictionary, no more words
000050r 1               
000050r 1                   ; update link list
000050r 1  A5 ED            lda wrk + 1
000052r 1  85 E9            sta tos + 1
000054r 1               
000054r 1                   ; wrk = [tos]
000054r 1  A2 08            ldx #(tos - nil) ; from
000056r 1  A0 0C            ldy #(wrk - nil) ; into
000058r 1  20 rr rr         jsr pull
00005Br 1               
00005Br 1                   ; bypass link
00005Br 1                   ; ldx #(tos - nil)
00005Br 1  A9 02            lda #2
00005Dr 1  20 rr rr         jsr add2w
000060r 1               
000060r 1                   ; save the flag at size byte
000060r 1  A5 E8            lda tos + 0
000062r 1  85 EC            sta wrk + 0
000064r 1               
000064r 1                   ; compare words
000064r 1  A0 00            ldy #0
000066r 1               @equal:
000066r 1  B1 EA            lda (nos), y
000068r 1  C9 20            cmp #32         ; space ends token
00006Ar 1  F0 0A            beq @done
00006Cr 1                   ; verify
00006Cr 1  38               sec
00006Dr 1  F1 E8            sbc (tos), y    ;
00006Fr 1  29 7F            and #$7F        ; 7-bit ascii, also mask flag
000071r 1  D0 D5            bne @loop
000073r 1                   ; next char
000073r 1  C8               iny
000074r 1  D0 F0            bne @equal
000076r 1               @done:
000076r 1               
000076r 1                   ; update
000076r 1  98               tya
000077r 1                   ; ldx #(tos - nil)
000077r 1  20 rr rr         jsr add2w
00007Ar 1               
00007Ar 1                   ; compile or execute
00007Ar 1  A5 EC            lda wrk + 0     ; immediate ?
00007Cr 1  30 07            bmi @execw      ; if < 0
00007Er 1               
00007Er 1  A5 F0            lda state + 0   ; executing ?
000080r 1  D0 03            bne @execw
000082r 1               
000082r 1  4C rr rr         jmp compile
000085r 1               
000085r 1               @execw:
000085r 1               
000085r 1  4C rr rr         jmp next_
000088r 1               
000088r 1               ;---------------------------------------------------------------------
000088r 1               getline_:
000088r 1                   ; leave a space
000088r 1  A0 01            ldy #1
00008Ar 1               @loop:
00008Ar 1  20 rr rr         jsr getchar
00008Dr 1  C9 0A            cmp #10         ; lf ?
00008Fr 1  F0 08            beq @endline
000091r 1                   ;    cmp #13     ; cr ?
000091r 1                   ;   beq @ends
000091r 1                   ;   cmp #8      ; bs ?
000091r 1                   ;   bne @puts
000091r 1                   ;   dey
000091r 1                   ;   jmp @loop
000091r 1               @puts:
000091r 1  29 7F            and #$7F        ; 7-bit ascii
000093r 1  99 rr rr         sta tib, y
000096r 1  C8               iny
000097r 1                   ;   cpy #254
000097r 1                   ;   beq @ends   ; leave ' \0'
000097r 1  D0 F1            bne @loop
000099r 1               @endline:
000099r 1                   ; grace
000099r 1  A9 20            lda #32
00009Br 1  8D rr rr         sta tib + 0 ; start with space
00009Er 1  99 rr rr         sta tib, y  ; ends with space
0000A1r 1  C8               iny
0000A2r 1  A9 00            lda #0      ; mark end of line
0000A4r 1  99 rr rr         sta tib, y
0000A7r 1                   ; reset line
0000A7r 1  85 F3            sta toin + 1
0000A9r 1  60               rts
0000AAr 1               
0000AAr 1               ;---------------------------------------------------------------------
0000AAr 1               try_:
0000AAr 1  B9 rr rr         lda tib, y
0000ADr 1  F0 04            beq newline    ; if \0
0000AFr 1  C8               iny
0000B0r 1  49 20            eor #32
0000B2r 1  60               rts
0000B3r 1               
0000B3r 1               newline:
0000B3r 1                   ; drop skip scan
0000B3r 1  68               pla
0000B4r 1  68               pla
0000B5r 1                   ; load a line
0000B5r 1  20 rr rr         jsr getline_
0000B8r 1               
0000B8r 1               token:
0000B8r 1                   ; last position on tib
0000B8r 1  A4 F3            ldy toin + 1
0000BAr 1               
0000BAr 1               @skip:
0000BAr 1                   ; skip spaces
0000BAr 1  20 rr rr         jsr try_
0000BDr 1  F0 FB            beq @skip
0000BFr 1               
0000BFr 1                   ; keep start
0000BFr 1  88               dey
0000C0r 1  84 F2            sty toin + 0
0000C2r 1               
0000C2r 1               @scan:
0000C2r 1                   ; scan spaces
0000C2r 1  20 rr rr         jsr try_
0000C5r 1  D0 FB            bne @scan
0000C7r 1               
0000C7r 1                   ; keep stop
0000C7r 1  88               dey
0000C8r 1  84 F3            sty toin + 1    ; save position
0000CAr 1               
0000CAr 1                   ; strlen
0000CAr 1  38               sec
0000CBr 1  98               tya
0000CCr 1  E5 F2            sbc toin + 0
0000CEr 1               
0000CEr 1                   ; place size
0000CEr 1  C6 F2            dec toin + 0
0000D0r 1  A4 F2            ldy toin + 0
0000D2r 1  99 rr rr         sta tib, y    ; store size ahead
0000D5r 1               
0000D5r 1                   ; setup token
0000D5r 1  84 EA            sty nos + 0
0000D7r 1  A9 rr            lda #>tib
0000D9r 1  85 EB            sta nos + 1
0000DBr 1               
0000DBr 1  60               rts
0000DCr 1               
0000DCr 1               ;---------------------------------------------------------------------
0000DCr 1               
0000DCr 1               ; increment a word in page zero, offset by X
0000DCr 1               incw:
0000DCr 1  A9 01            lda #1
0000DEr 1               ; add a byte to a word in page zero. offset by X
0000DEr 1               add2w:
0000DEr 1  18               clc
0000DFr 1  75 E0            adc nil + 0, x
0000E1r 1  95 E0            sta nil + 0, x
0000E3r 1  90 02            bcc @noinc
0000E5r 1  F6 E1            inc nil + 1, x
0000E7r 1               @noinc:
0000E7r 1  60               rts
0000E8r 1               
0000E8r 1               ; decrement a word in page zero. offset by X
0000E8r 1               decw:
0000E8r 1  B5 E0            lda nil + 0, x
0000EAr 1  D0 02            bne @nodec
0000ECr 1  D6 E1            dec nil + 1, x
0000EEr 1               @nodec:
0000EEr 1  D6 E0            dec nil + 0, x
0000F0r 1  60               rts
0000F1r 1               
0000F1r 1               ; pull a word
0000F1r 1               ; from a page zero address indexed by X
0000F1r 1               ; into a absolute page zero address indexed by y
0000F1r 1               spull2:
0000F1r 1  20 rr rr         jsr spull
0000F4r 1               spullnos:
0000F4r 1  A0 0A            ldy #(nos - nil)
0000F6r 1  2C               .byte $2c   ; mask ldy, nice trick !
0000F7r 1               ; pull from data stack
0000F7r 1               spull:
0000F7r 1  A0 08            ldy #(tos - nil)
0000F9r 1  A2 04            ldx #(dta - nil)
0000FBr 1               pull:
0000FBr 1  A1 E0            lda (nil, x)
0000FDr 1  99 E0 00         sta nil + 0, y
000100r 1  20 rr rr         jsr incw
000103r 1  A1 E0            lda (nil, x)
000105r 1  99 E1 00         sta nil + 1, y
000108r 1  4C rr rr         jmp incw
00010Br 1               
00010Br 1               ; push a word
00010Br 1               ; from an absolute page zero address indexed by Y
00010Br 1               ; into a page zero address indexed by X
00010Br 1               ; push into data stack
00010Br 1               spush:
00010Br 1  A2 04            ldx #(dta - nil)
00010Dr 1               tospush:
00010Dr 1  A0 08            ldy #(tos - nil)
00010Fr 1               push:
00010Fr 1  20 rr rr         jsr decw
000112r 1  B9 E1 00         lda nil + 1, y
000115r 1  81 E0            sta (nil, x)
000117r 1  20 rr rr         jsr decw
00011Ar 1  B9 E0 00         lda nil + 0, y
00011Dr 1  81 E0            sta (nil, x)
00011Fr 1  60               rts
000120r 1               
000120r 1               ;---------------------------------------------------------------------
000120r 1               ; for lib6502  emulator
000120r 1               getchar:
000120r 1  AD 00 E0         lda $E000
000123r 1               
000123r 1               putchar:
000123r 1  8D 00 E0         sta $E000
000126r 1  60               rts
000127r 1               
000127r 1               ;---------------------------------------------------------------------
000127r 1               ; primitives ends with jmp link_
000127r 1               ;
000127r 1               ;def_word "emit", "emit", 0
000127r 1               ;   jsr spull
000127r 1               ;   lda tos + 0
000127r 1               ;   jsr putchar
000127r 1               ;   jmp link_
000127r 1               ;
000127r 1               ;def_word "key", "key", 0
000127r 1               ;   jsr getchar
000127r 1               ;   sta tos + 0
000127r 1               ;   jsr spush
000127r 1               ;   jmp link_
000127r 1               ;
000127r 1               ;---------------------------------------------------------------------
000127r 1               ; [tos] = nos
000127r 1  00 00 01 21  def_word "!", "store", 0
00012Br 1               storew:
00012Br 1  20 rr rr         jsr spull2
00012Er 1  A2 08            ldx #(tos - nil)
000130r 1  A0 0A            ldy #(nos - nil)
000132r 1  20 rr rr         jsr push
000135r 1  4C rr rr         jmp link_
000138r 1               
000138r 1               ;---------------------------------------------------------------------
000138r 1               ; tos = [nos]
000138r 1  rr rr 01 40  def_word "@", "fetch", 0
00013Cr 1               fetchw:
00013Cr 1  20 rr rr         jsr spullnos
00013Fr 1  A2 0A            ldx #(nos - nil)
000141r 1  A0 08            ldy #(tos - nil)
000143r 1  20 rr rr         jsr pull
000146r 1  4C rr rr         jmp used
000149r 1               
000149r 1               ;---------------------------------------------------------------------
000149r 1  rr rr 02 73  def_word "s@", "statevar", 0
00014Dr 1  40           
00014Er 1  A9 F0            lda #<state
000150r 1  85 E8            sta tos + 0
000152r 1  A9 00            lda #>state
000154r 1               back:
000154r 1  85 E9            sta tos + 1
000156r 1               used:
000156r 1  20 rr rr         jsr spush
000159r 1  4C rr rr         jmp link_
00015Cr 1               
00015Cr 1               ;---------------------------------------------------------------------
00015Cr 1  rr rr 03 72  def_word "rp@", "rpfetch", 0
000160r 1  70 40        
000162r 1  A5 E6            lda ret + 0
000164r 1  85 E8            sta tos + 0
000166r 1  A5 E7            lda ret + 1
000168r 1  4C rr rr         jmp back
00016Br 1               
00016Br 1               ;---------------------------------------------------------------------
00016Br 1  rr rr 03 73  def_word "sp@", "spfetch", 0
00016Fr 1  70 40        
000171r 1  A5 E4            lda dta + 0
000173r 1  85 E8            sta tos + 0
000175r 1  A5 E5            lda dta + 1
000177r 1  4C rr rr         jmp back
00017Ar 1               
00017Ar 1               ;---------------------------------------------------------------------
00017Ar 1               ; ( nos tos -- nos + tos )
00017Ar 1  rr rr 01 2B  def_word "+", "plus", 0
00017Er 1  20 rr rr         jsr spull2
000181r 1  18               clc
000182r 1  A5 EA            lda nos + 0
000184r 1  65 E8            adc tos + 0
000186r 1  85 E8            sta tos + 0
000188r 1  A5 EB            lda nos + 1
00018Ar 1  65 E9            adc tos + 1
00018Cr 1  4C rr rr         jmp back
00018Fr 1               
00018Fr 1               ;---------------------------------------------------------------------
00018Fr 1               ; ( nos tos -- NOT(nos AND tos) )
00018Fr 1  rr rr 04 6E  def_word "nand", "nand", 0
000193r 1  61 6E 64     
000196r 1  20 rr rr         jsr spull2
000199r 1  A5 EA            lda nos + 0
00019Br 1  25 E8            and tos + 0
00019Dr 1  49 FF            eor #$FF
00019Fr 1  85 E8            sta tos + 0
0001A1r 1  A5 EB            lda nos + 1
0001A3r 1  25 E9            and tos + 1
0001A5r 1  49 FF            eor #$FF
0001A7r 1  4C rr rr         jmp back
0001AAr 1               
0001AAr 1               ;---------------------------------------------------------------------
0001AAr 1  rr rr 02 30  def_word "0#", "zeroq", 0
0001AEr 1  23           
0001AFr 1  20 rr rr         jsr spull
0001B2r 1                   ; lda tos + 1
0001B2r 1  05 E8            ora tos + 0
0001B4r 1  F0 06            beq istrue  ; is \0
0001B6r 1               isfalse:
0001B6r 1  A9 00            lda #$00
0001B8r 1               rest:
0001B8r 1  85 E8            sta tos + 0
0001BAr 1  F0 98            beq back
0001BCr 1               istrue:
0001BCr 1  A9 FF            lda #$FF
0001BEr 1  D0 F8            bne rest
0001C0r 1               
0001C0r 1               ;---------------------------------------------------------------------
0001C0r 1  rr rr 02 32  def_word "2/", "asr", 0
0001C4r 1  2F           
0001C5r 1  20 rr rr         jsr spull
0001C8r 1  46 E9            lsr tos + 1
0001CAr 1  66 E8            ror tos + 0
0001CCr 1  4C rr rr         jmp used
0001CFr 1               
0001CFr 1               ;---------------------------------------------------------------------
0001CFr 1               ; minimal indirect thread code
0001CFr 1               ; lnk must be preserved, as IP
0001CFr 1               ;
0001CFr 1  rr rr 04 65  def_word "exit", "exit", 0
0001D3r 1  78 69 74     
0001D6r 1               unnest_:
0001D6r 1                   ; pull from return stack
0001D6r 1  A2 06            ldx #(ret - nil)
0001D8r 1  A0 08            ldy #(tos - nil)
0001DAr 1  20 rr rr         jsr pull
0001DDr 1               
0001DDr 1               inner:
0001DDr 1               
0001DDr 1               next_:
0001DDr 1                   ; lnk = [tos]
0001DDr 1  A2 08            ldx #(tos - nil)
0001DFr 1  A0 02            ldy #(lnk - nil)
0001E1r 1  20 rr rr         jsr pull
0001E4r 1               
0001E4r 1                   ; is a primitive ?
0001E4r 1  A5 E3            lda lnk + 1
0001E6r 1  C9 rr            cmp #>init    ; magic high byte of init:
0001E8r 1  90 10            bcc jump_
0001EAr 1               
0001EAr 1               nest_:
0001EAr 1                   ; push into return stack
0001EAr 1  A2 06            ldx #(ret - nil)
0001ECr 1  20 rr rr         jsr tospush
0001EFr 1               
0001EFr 1               link_:
0001EFr 1  A5 E2            lda lnk + 0
0001F1r 1  85 E8            sta tos + 0
0001F3r 1  A5 E3            lda lnk + 1
0001F5r 1  85 E9            sta tos + 1
0001F7r 1  4C rr rr         jmp next_
0001FAr 1               
0001FAr 1               jump_:
0001FAr 1                   ; pull from return stack
0001FAr 1  A2 06            ldx #(ret - nil)
0001FCr 1  A0 02            ldy #(lnk - nil)
0001FEr 1  20 rr rr         jsr pull
000201r 1  6C E8 00         jmp (tos)
000204r 1               
000204r 1               ;---------------------------------------------------------------------
000204r 1  rr rr 01 3A  def_word ":", "colon", 0
000208r 1                   ; save here, to update last
000208r 1  A2 04            ldx #(dta - nil)
00020Ar 1  A0 16            ldy #(here - nil)
00020Cr 1  20 rr rr         jsr push
00020Fr 1               
00020Fr 1                   ; update the link field with last
00020Fr 1  A2 16            ldx #(here - nil)
000211r 1  A0 14            ldy #(last - nil)
000213r 1  20 rr rr         jsr push
000216r 1               
000216r 1                   ; get the token, at nos
000216r 1  20 rr rr         jsr token
000219r 1               
000219r 1                   ;copy size and name
000219r 1  A0 00            ldy #0
00021Br 1               @loop:
00021Br 1  B1 EA            lda (nos), y
00021Dr 1  C9 20            cmp #32     ; stops at space
00021Fr 1  F0 05            beq @endname
000221r 1  91 F6            sta (here), y
000223r 1  C8               iny
000224r 1  D0 F5            bne @loop
000226r 1               @endname:
000226r 1               
000226r 1                   ; update here
000226r 1  98               tya
000227r 1  A2 16            ldx #(here - nil)
000229r 1  20 rr rr         jsr add2w
00022Cr 1               
00022Cr 1                   ; state is 'compile'
00022Cr 1               
00022Cr 1  A9 00            lda #0
00022Er 1  85 F0            sta state + 0
000230r 1               
000230r 1  4C rr rr         jmp link_
000233r 1               
000233r 1               ;---------------------------------------------------------------------
000233r 1  rr rr 81 3B  def_word ";", "semis", FLAG_IMM
000237r 1               
000237r 1                   ; update last
000237r 1               
000237r 1  A2 04            ldx #(dta - nil)
000239r 1  A0 14            ldy #(last - nil)
00023Br 1  20 rr rr         jsr pull
00023Er 1               
00023Er 1                   ; state is 'interpret'
00023Er 1  A9 01            lda #1
000240r 1  85 F0            sta state + 0
000242r 1               
000242r 1                   ; compounds ends with 'unnest'
000242r 1  A9 rr            lda #<unnest_
000244r 1  85 E8            sta tos + 0
000246r 1  A9 rr            lda #>unnest_
000248r 1  85 E9            sta tos + 1
00024Ar 1               
00024Ar 1               compile:
00024Ar 1               
00024Ar 1  A2 16            ldx #(here - nil)
00024Cr 1  20 rr rr         jsr tospush
00024Fr 1               
00024Fr 1  4C rr rr         jmp link_
000252r 1               
000252r 1               ;---------------------------------------------------------------------
000252r 1               ends:
000252r 1               
000252r 1               ; debug stuff
000252r 1               .if 0
000252r 1               
000252r 1               erro:
000252r 1                   lda #'?'
000252r 1                   jsr putchar
000252r 1                   lda #'?'
000252r 1                   jsr putchar
000252r 1                   lda #10
000252r 1                   jsr putchar
000252r 1                   lda #13
000252r 1                   jsr putchar
000252r 1                   rts
000252r 1               
000252r 1               okey:
000252r 1                   lda #'O'
000252r 1                   jsr putchar
000252r 1                   lda #'K'
000252r 1                   jsr putchar
000252r 1                   lda #10
000252r 1                   jsr putchar
000252r 1                   lda #13
000252r 1                   jsr putchar
000252r 1                   rts
000252r 1               
000252r 1               .endif
000252r 1               
000252r 1               
000252r 1  xx xx xx xx  .align $100
000256r 1  xx xx xx xx  
00025Ar 1  xx xx xx xx  
000300r 1               
000300r 1               ; terminal input buffer, 256 bytes
000300r 1               tib:
000300r 1  00 00 00 00  .res SIZES, $0
000304r 1  00 00 00 00  
000308r 1  00 00 00 00  
000400r 1               
000400r 1               ; return stack base, 128 words deep
000400r 1  00 00 00 00  .res SIZES, $0
000404r 1  00 00 00 00  
000408r 1  00 00 00 00  
000500r 1               rsb:
000500r 1               
000500r 1               ; data stack base, 128 words deep
000500r 1  00 00 00 00  .res SIZES, $0
000504r 1  00 00 00 00  
000508r 1  00 00 00 00  
000600r 1               dsb:
000600r 1               
000600r 1  00 00        void: .word $0
000602r 1               ; for anything above is not a primitive
000602r 1               init:
000602r 1               
000602r 1               
